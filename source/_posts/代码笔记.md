---
title: 代码笔记
typora-root-url: 代码笔记
abbrlink: 458d0a8
date: 2023-01-07 14:32:04
keywords: '代码笔记'
tags: 
categories: 
photos:
description: 代码笔记
---

代码笔记

<!--more-->

------



## 类之间转换

BeanUtils.copyProperties("转换前的类", "转换后的类");  

有几点我们需要注意： BeanUtils.copyProperties(a, b); 

b中的存在的属性，a中一定要有，但是a中可以有多余的属性；

a中与b中相同的属性都会被替换，不管是否有值；a、 b中的属性要名字相同，才能被赋值，不然的话需要手动赋值；

Spring的BeanUtils的CopyProperties方法需要对应的属性有getter和setter方法；

如果存在属性完全相同的内部类，但是不是同一个内部类，即分别属于各自的内部类，则spring会认为属性不同，不会copy；

spring和apache的copy属性的方法源和目的参数的位置正好相反，所以导包和调用的时候都要注意一下。

## 幂等

### **什么是幂等**

**幂等性：**多次调用方法或者接口不会改变业务状态，可以保证重复调用的结果和单次调用的结果一致。

### **使用幂等的场景**

**1、前端重复提交**

用户注册，用户创建商品等操作，前端都会提交一些数据给后台服务，后台需要根据用户提交的数据在数据库中创建记录。如果用户不小心多点了几次，后端收到了好几次提交，这时就会在数据库中重复创建了多条记录。这就是接口没有幂等性带来的 bug。

**2、接口超时重试**

对于给第三方调用的接口，有可能会因为网络原因而调用失败，这时，一般在设计的时候会对接口调用加上失败重试的机制。如果第一次调用已经执行了一半时，发生了网络异常。这时再次调用时就会因为脏数据的存在而出现调用异常。

**3、消息重复消费**

在使用消息中间件来处理消息队列，且手动 ack 确认消息被正常消费时。如果消费者突然断开连接，那么已经执行了一半的消息会重新放回队列。

当消息被其他消费者重新消费时，如果没有幂等性，就会导致消息重复消费时结果异常，如数据库重复数据，数据库数据冲突，资源重复等。

### **解决方案**

**1、token 机制实现**

通过token 机制实现接口的幂等性,这是一种比较通用性的实现方法。

示意图如下：

 ![img](./v2-a813e4f94b89049877fe513264e0eb5d_720w.webp)

 

具体流程步骤：

1. 客户端会先发送一个请求去获取 token，服务端会生成一个全局唯一的 ID 作为 token 保存在 redis 中，同时把这个 ID 返回给客户端
2. 客户端第二次调用业务请求的时候必须携带这个 token
3. 服务端会校验这个 token，如果校验成功，则执行业务，并删除 redis 中的 token
4. 如果校验失败，说明 redis 中已经没有对应的 token，则表示重复操作，直接返回指定的结果给客户端

注意：

1. 对 redis 中是否存在 token 以及删除的代码逻辑建议用 Lua 脚本实现，保证原子性
2. 全局唯一 ID 可以用百度的 uid-generator、美团的 Leaf 去生成

**2、基于 mysql 实现**

这种实现方式是利用 mysql 唯一索引的特性。

示意图如下：

 ![img](./v2-dc3df46efad1657a9785aebbc2069b5c_720w.webp)

 

具体流程步骤：

1. 建立一张去重表，其中某个字段需要建立唯一索引
2. 客户端去请求服务端，服务端会将这次请求的一些信息插入这张去重表中
3. 因为表中某个字段带有唯一索引，如果插入成功，证明表中没有这次请求的信息，则执行后续的业务逻辑
4. 如果插入失败，则代表已经执行过当前请求，直接返回

**3、基于 redis 实现**

这种实现方式是基于 SETNX 命令实现的

SETNX key value：将 key 的值设为 value ，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作。

该命令在设置成功时返回 1，设置失败时返回 0。

示意图如下：  

 ![img](./v2-6ae389fa7bcb099a8f8a6eaf89f5f46d_720w.webp)

 

具体流程步骤：

1. 客户端先请求服务端，会拿到一个能代表这次请求业务的唯一字段
2. 将该字段以 SETNX 的方式存入 redis 中，并根据业务设置相应的超时时间
3. 如果设置成功，证明这是第一次请求，则执行后续的业务逻辑
4. 如果设置失败，则代表已经执行过当前请求，直接返回

### **总结**

这几种实现幂等的方式其实都是大同小异的，类似的还有使用状态机、悲观锁、乐观锁的方式来实现，都是比较简单的。

