---
title: 关于JVM
typora-root-url: 关于JVM
date: 2022-11-26 14:43:05
tags:
permalink:
---



## JVM

JVM是Java Virtual Machine的缩写，即咱们经常提到的Java虚拟机。虚拟机是一种抽象化的计算机，有着自己完善的硬件架构，如处理器、堆栈等，具体有什么咱们不做了解。

java怎么实现跨平台

java- 通过—javac-  把文件编译成→class-- 由--jvm-->解释成各个平台都能使用的字节码--->实现跨平台

传输协议三次握手

为什么不适用UDP

 因为UDP把数据传输过去就不管了，就假定接收方一定能接收到在网络环境中无时无刻出现着丢包、阻塞、乱序的情况，一个不小心，数据可能就传输不到目的地了，这个时候就只能轮到TCP了

## jvm的组成成分

 ![img](lu152441l02jn_tmp_625698d2d9f3be4c.png) 

## 垃圾回收机制

主要：

1垃圾回收机制判断方式：引用计数算法 可达性分析算法 。

垃圾：没有任何引用指向的一个对象或者多个对象（循环引用），称为垃圾

### 1、引用计数法

  引用计数法是一种简单粗暴的方法，JVM会为每个对象维护一个计数器，对象每次被引用一次，计数器就加1，但引用失效时，计数器就减1；而当引用计数为0时这个对象就会被标记为垃圾；

引用计数法

优点:实现简单，判定效率也比较高. 比如Python语言就采用引用计数法进行内存管理(它引入了一个全局解释器锁 GIL)。

缺点:主流的JVM中没有选用引用计数法来管理内存，最主要的原因

1. 引用计数法无法解决对象的循环引用问题，
2. 在多线程时为了保证引用计数的正确性，还需要对计数器加锁，效率也会下降。

![img](lu152441l02jn_tmp_ae0e400be7ea396c.png) 

![img](lu152441l02jn_tmp_2c2dd5b8c801290a.png) 

循环引用的情况下，他们的引用计数器都不为0，但是实际他们已经找不到了，因为没有指针向他们，这时就会发生内存泄漏。

### 2、可达性分析算法

  在Java中一般都会采用可达性分析算法去判断这个对象需不需要回收，核心思想是：通过一系列“GC Roots”对象为起始点，然后向下搜索，搜索的路径称为“引用链”

如果一个对象没有任何一个与“GC Roots”相连的引用链，则称这个对象为不可达对象。

 "GCroots，或者说tracingGC的“根集合”就是一组必须活跃的引用  

![img](lu152441l02jn_tmp_f813789a5fa9b868.png) 

引用是单向的，指向它的引用断了，它就会被标记为不可达

什么样的对象才可以作为"GC Roots"对象。

1. 虚拟机栈(栈帧中的本地变量表)中引用的对象
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中JNI(Native方法)引用的对象

  引用被分为了四个类型：强引用、软引用、弱引用、虚引用， java代码就是强引用

- 强引用：强引用指的是类似java代码的引用，只要强引用还存在，被引用的对象实例永远不会被回收
- 软引用：软引用是用来描述一些还有用但是不是必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出之前，会把这些对象列入回收范围之中进行第二次回收。如果第二次回收还是没有足够的内存，就会释放被软引用引用的对象。
- 弱引用：弱引用也是用来描述非必需对象的。但是它的强度要弱于软引用。被弱引用关联的对象只能生存到下一次垃圾回收发生之前。当垃圾回收器开始进行工作时，无论当前内容是否够用，都会回收掉只被弱引用关联的对象。
- 虚引用：虚引用也被称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

#### 被标记为不可达对象就一定会被回收吗？

 答案是不一定，一般一个对象至少需要经过两次可达性分析才会被回收，一个对象第一次被标记后JVM会进行一次筛选，判定他它是否需要执行finalize()方法，如果这个对象没有覆盖finalize()方法或者finalize()方法已经被执行过一次了，那么这个对象就会被判断为不需要执行，直接进行回收；

 如果判定需要执行，就会把这个对象加入一个F-Queue的队列中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它，就是由JVM去调用这个对象的finalize()方法(   finalize ()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。

 )，之后GC将会对F-Queue进行第二次小规模的标记，如果对象在finalize()中成功拯救自己(只需要重新与引用链上的任何一个对象建立起关联关系即可)，那在第二次标记时它将会被移除出"即将回收"的集合；

 如果对象这时候还是没有逃脱，那基本上它就是真的被回收了。

#### 2内存划分区域是那些，那些是公有的和私有的

 JVM 运行时数据区域大致可以分为：程序计数器、虚拟机栈、本地方法栈、堆区、元空间、运行时常量池(在方法区中)、直接内存(不是Java定义的内存的一部分)等区域；就是下面这个样子的：

 ![img](lu152441l02jn_tmp_3fe3e267298c66d7.png) 

 ![img](lu152441l02jn_tmp_180a61cf6ac87698.png) 

 其中有些区域，随着 JDK 版本的升级不断调整，例如：

 JDK 1.6，字符串常量池位于永久代的运行时常量池中；JDK 1.7，字符串常量池从永久代剥离，放入了堆中；JDK 1.8，元空间取代了永久代，并且放入了本地内存（Native memory）中。以上几个区域，按照线程公有还是私有可分为：

 线程隔离：程序计数器、虚拟机栈、本地方法栈；线程公有：其它的都是线程共享的区域。线程私有

 ![img](lu152441l02jn_tmp_2856863cbfde6210.png) 

 \1. 程序计数器

 一个 CPU 在某个时间点，只能做一件事情，在多线程的情况下，CPU 运行时间被划分成若干个时间片，分配给各个线程执行；

 程序计数器的作用就是记录当前线程执行的位置，当线程被切换回来的时候，能够找到该线程上次运行到哪儿了；所以程序计数器一定是线程隔离的。

 \2. 虚拟机栈和本地方法栈

 虚拟机栈：每个 Java 方法在执行的同时，会创建一个栈帧，用于存储局部变量表、操作数栈、常量池引用等信息；方法的调用过程，就是一个栈帧在 Java 虚拟机栈中入栈和出栈的过程；

 本地方法栈：和虚拟机栈很类似，区别在于虚拟机栈为 Java 方法服务，本地方法栈为 Native 方法服务；其中 Native 方法可以看做用其它语言（C、C++ 或汇编语言等）编写的方法；HotSpot 虚拟机就选择了将虚拟机栈和本地方法栈合并在了一起；为了保证线程中的局部变量不被别的线程访问到，所以虚拟机栈和本地方法栈是线程隔离的。

 线程公有

 ![img](lu152441l02jn_tmp_37be792b63608286.png) 

 \1. 堆区

 对于堆栈的区别总结一句话：堆中存对象，栈中存基本数据类型和堆中对象的引用；一个对象的大小是可以动态变化的，而引用是固定大小的。

 这么看就容易理解堆为什么是线程公有的了，省地儿啊。

 \2. 元空间区/方法区

 方法区用于存放已被加载的类信息、常量、静态变量、即编译器编译后的代码。

 还有要注意的一点：方法区是 JVM 的规范，在 JDK 1.8 之前，方法区的实现是永久代；从 JDK 1.8 开始 JVM 移除了永久代，使用本地内存来存储元数据并称之为：元空间（Metaspace）。

 \3. 运行时常量池

 Class 文件中的常量池，会在类加载后被放入这个区域。

 另外在 JDK 1.7 之前，字符串常量池就在运行时常量池中，1.7字符串常量池放入了堆中，而运行时常量池仍然在方法区（元空间区）中。

 有兴趣的朋友可以自己测试一下，以死循环方式创建字符串常量，JDK 1.6 会报永久代 OOM ；JDK 1.7 会报堆区 OOM 。

 \4. 直接内存

 也叫做堆外内存，并不是虚拟机运行时数据区的一部分，也不是Java 虚拟机规范中定义的内存区域。

 JDK 1.4 加入的 NIO 类，引入了一种基于通道 ( Channel ) 与缓冲区 ( Buffer ) 的 I/O 方式，它可以使用 native 函数库直接分配堆外内存，然后通过堆上的DirectByteBuffer对象对这块内存进行引用和操作。

 简单来说，直接内存就是 JVM 内存之外有一块内存区域，我们通过堆上的一个对象可以操作它  

3 垃圾回收 三种方法，

复制算法，标记整理算法，标记清楚算法  

的优缺点和使用场景。

新生代（有什么重要参数），老年代，永久代。Eden区，from区，to区 ，及比例。minor GC ，minor GC 。

 垃圾回收算法有⼏种类型？他们对应的优缺点⼜是什么？

 怎么判断一个对象是否是垃圾呢，就是沿着GC Root对象的引用链去找，扫描整个堆对象的过程中，如果发现对象确实被引用了，那么它需要保留，如果没有GC Root直接或间接地引用它，那么它就可以当成是垃圾进行一个回收。

 常见的垃圾回收算法有：

 标记-清除算法、复制算法、标记-整理算法、分代收集算法

 标记-清除算法

 第一个阶段先标记，看看哪些对象可以是垃圾，第二个阶段是清除，所谓的清除就是把垃圾对象所占用的空间释放

 这里可能会有一个小误区，释放是不是意味着把整个内存每个字节进行一个清零操作呢，注意：不会，它只需要把对象所占用内存的起始、结束的地址给记录下来，放在一个空闲的地址列表里就可以了，下次再分配新对象的时候就到空闲地址列表中去找看有没有一块足够的空间容纳新对象，如果有，那就进行一个内存分配，并不会把可以作为垃圾的对象占用的内存做一个清零的处理。

 优点：标记清除算法的特点就是简单直接，速度也非常块，特别适合可回收对象不多的场景。

 清除操作只需要把垃圾对象内存的起始、结束地址作为一个记录就完成了，不需要做更多的额外处理，所以整个垃圾回收的速度相对是比较快的。
 缺点：1、会造成不连续的内存空间：清除后内存会有很多不连续的空间，这也就是我们常说的空间碎片，这样的空间碎片太多不仅不利于我们下次分配，而且当有大对象创建的时候，我们明明有可以容纳的总空间，但是空间都不是连续的造成对象无法分配，从而不得不提前触发GC。
 2、性能不稳定：内存中需要回收的对象，当内存中大量对象都是需要回收的时候，通常这些对象可能比较分散，所以清除的过程会比较耗时，这个时候清理的速度就会比较慢了。

 标记复制算法

 复制算法。复制算法比较特殊一些，它是把内存区域划成了大小相等的两块区域，

 左边的称为FROM，右边的称之为TO，其中TO这个区域始终空闲着，里面一个对象都没有，那它是怎么做垃圾回收的呢，它也是首先做一次标记，找到那些不被引用的对象标记为垃圾，然后从FROM区域上把FROM区域上还存活的对象复制到TO区域中，复制的过程中就会完成碎片的整理，也是不会产生碎片，等复制完成可以看到FROM区域全是垃圾了（这里指的是FROM区域的内存空间都当作空白内存用了），都没用了，一下子清空，并且交换FROM和TO它俩的位置，原来的TO变成了FROM，原来的FROM变成了TO，TO总是空闲的一块空间。

 优点

 不会产生内存碎片

 缺点

 复制算法会占用双倍的内存空间

 标记-整理算法

 标记整理，分为两个阶段：标记+整理，标记整理和标记清除算法在第一个阶段是一样的，也是

 先对对象进行一个标记，看看哪些对象是垃圾，区别主要在第二步上，整理避免了之前标记清除时内存碎片的问题，整理会在清除的过程中，把可用的对象向前移动，让内存更为紧凑，避免内存碎片的产生。整理之后发现内存更紧凑了，连续的空间更多了，这样就不会造成标记清除算法内存碎片的问题，

 优点

 避免了内存碎片的产生

 缺点

 速度慢

 由于整理牵扯到了对象的移动，效率会变得较低，对象在整理过程中要移动，移动的过程中如果有一些局部变量引用了存活的对象，肯定需要改变引用的引用地址，对象在内存中的位置变了，地址变了，肯定设计的工作就比较多一些，前者到内存区块的拷贝移动，还要把所有引用的地址加以改变。总结：干的活比较多,算法复杂，速度慢一些。

 分代收集算法

 ⽬前⼤部分 JVM 的垃圾收集器采⽤的算法。根据对象存活的⽣命周期将内存划分为若⼲个不同的区域。⼀般情况下将堆区划分为新⽣代（

 Young Generation 和⽼年代（ Tenured Generation ），永久代（ Permanet Generation ）。

 ⽼年代的特点是每次垃圾收集时只有少量对象需要被回收，⽽新⽣代的特点是每次垃圾回收时都有⼤量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。

 Young：存放新创建的对象，对象⽣命周期⾮常短，⼏乎⽤完可以⽴即回收，也叫 Eden 区。

 Tenured： young 区多次回收后存活下来的对象将被移到 tenured 区，也叫 old 区。

 Perm：永久带，主要存加载的类信息，⽣命周期长，⼏乎不会被回收。

 缺点： 算法复杂度⼤，执⾏步骤较多。

 堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。而新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。

 新生代中一般保存新出现的对象，所以每次垃圾收集时都发现大批对象死去，只有少量对象存活，便采用了复制算法，只需要付出少量存活对象的复制成本就可以完成收集。

 老年代中一般保存存活了很久的对象，他们存活率高、没有额外空间对它进行分配担保，就必须采用“标记-清理”或者“标记-整理”算法。

 永久代就是JVM的方法区。在这里都是放着一些被虚拟机加载的类信息，静态变量，常量等数据。这个区中的东西比老年代和新生代更不容易回收。

 永久代和方法区区别

永久代是HotSpot的概念，方法区是Java虚拟机规范中的定义，是一种规范，而永久代是一种实现

## Java堆老年代( Old ) 和新生代 ( Young ) 的默认比例

 新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )。其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，Edem 和俩个Survivor 区域比例是 = 8 : 1 : 1。

 Minor GC是新生代GC，指的是发生在新生代的垃圾收集动作。由于java对象大都是朝生夕死的，所以Minor GC非常频繁，一般回收速度也比较快。（一般采用复制算法回收垃圾）

 Major GC发生在老年代的GC ，基本上发生了一次Major GC 就会发生一次 Minor GC。并且Major GC 的速度往往会比 Minor GC 慢 10 倍。

 什么时候发生Major GC？1、 对于一个大对象，我们会首先在Eden 尝试创建，如果创建不了，就会触发Minor GC； 2、 随后继续尝试在Eden区存放，发现仍然放不下； 3、尝试直接进入老年代，老年代也放不下； 4、触发 Major GC 清理老年代的空间； 5放的下成功；放不下 OOM；

4 jvm优化常用工具和优化过那些参数  

#### 设置编译模式

Int解释模式 : -Xint强制运行字节码，效率低

Comp编译模式 : -Xcomp 编译成native代码带来大程度的优化

 mix 混合模式 : -Xmix解释和编译混合进行，由jvm决定使用任意模式

#### 设置初始堆内存

Xmx : -Xmx1024m 设置最大堆内存为1024MB

Xms : -Xms1024m 设置初始堆内存为1024MB

Xss ：设置栈[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)的大小

### JDK工具

可以辅助我们进行性能调优和问题排查

JDK自带了很多性能监控工具，我们可以用这些工具来监测系统和排查内存性能问题。

![img](lu152441l02jn_tmp_e2eb4790017e6344.png) 

## Linux命令行工具

### top命令

top命令是我们在Linux下最常用的命令之一，它可以实时显示正在执行进程的 CPU 使用率、内存使用率以及系统负载等信息。其中上半部分显示的是系统的统计信息，下半部分显示的是进程的使用率统计信息。

![img](lu152441l02jn_tmp_6505e17fe47974cf.png) 

### vmstat命令

vmstat是VirtualMeomoryStatistics（虚拟内存统计）的缩写，可对操作系统的虚拟内存、进程、CPU活动进行监控。

### pidstat命令

如果是监视某个应用的上下文切换，可以使用 pidstat 命令监控指定进程的上下文切换。

### 调优工具

Jvisualvm  jdk自带的可视化工具 可以看内存的使用情况，线程执行的情况

 [arthas](https://arthas.aliyun.com/doc/) 阿尔萨斯 更直观更容易定位错误

 jvm调优工具

## 深拷贝和浅拷贝

所谓拷贝，就是赋值。把一个变量赋给另外一个变量，就是把变量的内容进行拷贝。把一个对象的值赋给另外一个对象，就是把一个对象拷贝一份。

基本类型赋值时，赋的是数据（所以，不存在深拷贝和浅拷贝的问题）

最简单的浅拷贝，因为，只是把arr1的地址拷贝的一份给了arr2，并没有把arr1的数据拷贝一份。所以，拷贝的深度不够

如果两个Person对象的name的地址值相同， 说明两个对象的name都指向同一个String对象，也就是浅拷贝,而如果两个对象的name的地址值不同， 那么就说明指向不同的String对象，也就是在拷贝Person对象的时候，同时拷贝了name引用的String对象， 也就是深拷贝。

### 浅拷贝的实现方法：

1.Object.assign()                assign  /əˈsaɪn/  

 把任意多个源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。

 let obj2 = Object.assign({}, obj1)

2.函数库lodash的_.clone方法

 var _ = require('lodash');

 var obj2 = _.clone(obj1);

### 深拷贝的实现方法：

1.JSON.parse()和JSON.stringify()

 let arr2 = JSON.parse(JSON.stringify(arr1));

 缺点是不能处理函数和正则

2.函数库lodash的_.cloneDeep方法

 var _ = require('lodash');

 var obj2 = _.cloneDeep(obj1);

3.jQuery.extend()方法

 $.extend(deepCopy,target,obj1,[objN])

应用场景从服务器抓取数据存放到store(仓库)中，通过props传递到页面，这个过程就需要进行数据的拷贝

## 双亲委派机制

 　　双亲委派机制是指当一个类加载器收到一个类加载请求时，该类加载器首先会把请求委派给父类加载器。每个类加载器都是如此，只有在父类加载器在自己的搜索范围内找不到指定类时，子类加载器才会尝试自己去加载。

## cap理论

CAP即：

- Consistency（一致性）
- Availability（可用性）
- Partition 	tolerance（分区容忍性）

这三个性质对应了分布式系统的三个指标：
 而CAP理论说的就是：一个分布式系统，不可能同时做到这三点。如下图：

![img](lu152441l02jn_tmp_b9d7cf3aba37e3ae.jpg) 

接下来将详细介绍C A P 三个指标的含义，以及三者如何权衡。

### C、 A、P的含义

借用一下维基百科CAP理论一文中关于C、A、P三者的定义。
 ①一致性：要么我给您返回一个错误，要么我给你返回绝对一致的最新数据，不难看出，其强调的是数据正确。

②可用性：我一定会给您返回数据，不会给你返回错误，但不保证数据最新，强调的是不出错。

③分区容忍性：我会一直运行，不管我的内部出现何种数据同步问题，强调的是不挂掉。

Partition（分区）：因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。

 Tolerance（容错）：在集群出现分区时，整个系统也要持续对外提供服务

### 权衡 C、A

之前提到,CAP理论说一个分布式系统不可能同时满足C、A、P这三个特性。那么我们就来分析C、A、P的权衡吧。

> note：其实这里有个关于CAP理论理解的误区。不要以为在所有时候都只能选择两个特性。在不存在网络失败的情况下（分布式系统正常运行时），C和A能够同时保证。只有当网络发生分区或失败时，才会在C和A之间做出选择。

对于一个分布式系统而言，P是前提，必须保证，因为只要有网络交互就一定会有延迟和数据丢失，这种状况我们必须接受，必须保证系统不能挂掉。所以只剩下C、A可以选择。要么保证数据一致性（保证数据绝对正确），要么保证可用性（保证系统不出错）。

当选择了C（一致性）时，如果由于网络分区而无法保证特定信息是最新的，则系统将返回错误或超时。

当选择了A（可用性）时，系统将始终处理客户端的查询并尝试返回最新的可用的信息版本，即使由于网络分区而无法保证其是最新的。

Euraka 分区时的自我保护机制:

Eureka Server在运行期间会去统计心跳成功的比例在15分钟之内是否低于85% , 如果低于85%， Eureka Server会认为当前实例的客户端与自己的心跳连接出现了网络故障，那么Eureka Server会把这些实例保护起来，让这些实例不会过期导致实例剔除。
 这样做的目的是为了减少网络不稳定或者网络分区的情况下，Eureka Server将健康服务剔除下线的问题。 使用自我保护机制可以使得Eureka 集群更加健壮和稳定的运行。

 进入自我保护状态后，会出现以下几种情况

 1.Eureka Server不再从注册列表中移除因为长时间没有收到心跳而应该剔除的过期服务 Eureka   

2.Server仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点上，保证当前节点依然可用。

Eureka 保证 AP  

 Eureka 看明白了这一点，因此在设计时就优先保证可用性。我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接 down 掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。  

如果 Eureka 服务节点在短时间里丢失了大量的心跳连接(注：可能发生了

网络故障)，那么个  

 Eureka 节点会进入“自我保护模式”，同时保留那些“心跳死亡”的服务注册信息不过期。此时，这个 Eureka 节点对于新的服务还能提供注册服务，对于“死亡”的仍然保留，以防还有客户端向其发起请求。当网络故障恢复后，这个 Eureka 节点会退出“自我保护模式”。Eureka 的哲学是，同时保留“好数据”与“坏数据”总比丢掉任何数据要更好。  

 Zookeeper  保 证 CP

  ZooKeeper 是个 CP 的，即任何时刻对 ZooKeeper 的访问请求能得到一致的数据结果，同时系统

对网络分割具备容错性、但是它不能保证每次服务请求的可用性(注：也就是在极端环境下，

ZooKeeper 可能会丢弃一些请求，消费者程序需要重新请求才能获得结果)。  

 例如：当 master 节点因为网络故障与其他节点失去联系时，剩余节点会重新进行 leader 选举。问题在于，选举 leader 的时间太长，30 ~ 120s, 且选举期间整个 zk 集群都是不可用的，这就导致在选举期间注册服务瘫痪。

## linux命令常用命令

打包部署  当项目打成jar包后通过  java -jar xxxjar包 运行jar包

移动   mv ./a路径/文件名  ./b路径     将文件移动到b路径内

 删除  rm -f 文件/目录

 杀进程的方法 kill -pid

 确定要杀死进程的PID或PPID

 \# ps -ef | grep PID

 以优雅的方式结束进程

 \# kill -l PID

## jvm如何排查生产环境cpu飙高的问题原因：

 1.CAS自旋没有控制自旋次数方案：  设置固定自旋次数

 2.死循环方案：                    全面考虑业务场景，设定退出标志条件，限制循环的次数

 3.被注入挖矿程序方案：            Redis不要能够被外网访问

 4.服务器被DDOS工具攻击方案：     通过限流，ip黑名单，图形验证码防止机器模拟攻击
 ![img](lu152441l02jn_tmp_e64daee1eaf37d57.jpg) 

 ![img](lu152441l02jn_tmp_65ec194ca88d9a1e.jpg) 

 ![img](lu152441l02jn_tmp_9bc99987bd89bfab.jpg) 

   \1. 先关闭docker2. 配置docker远程访问3.    重新配置，启动docker  