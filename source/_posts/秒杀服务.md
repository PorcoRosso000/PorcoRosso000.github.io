---
title: 秒杀服务
typora-root-url: 秒杀服务
abbrlink: 2b33c538
date: 2022-11-26 12:40:42
tags:
permalink:
---



## 秒杀项目流程:

项目启动同步将做秒杀活动的商品库存同步到redis

->用户到抢购商品页面的时候后台生成一个uuidpath存到redis中设置5分钟的过期时间 ,放到作用域传到前台

->用户将要结算购物车中商品进行支付或者直接点击支付的时候,将uuidpath以参数的形式传到后台

->请求到抢购接口,获取参数的uuidpath和redis 中是否相同,相同过期就删掉这个redis,重新生成新的uuidpath防止恶意用户知道地址,一直重复请求抢购接口(接口地址隐藏),将用户id+活动id+秒杀商品id作为键,5作为值,然后给用户请求接口的次数计数,超过5 ,就给用户返回一个系统繁忙的提示,给用户进行限流,再结合setinel的全局限流给接口进行全局限流

->然后以信号量的形式获取项目启动同步到redis中的库存

->购物车中一个商品被选中几次就获取几个对应商品的信号量,多个商品就拿对应的信号量

->获取到信号量之后才去mq中进行给获取到请求的用户进行削峰异步添加订单

->同时使用异步编排进行积分添加操作

->调用到支付接口区支付

->使用支付宝进行验签验证支付宝的用户

->是的话就去支付

->支付成功的话修改订单状态

->如果用户没有支付在5分钟后就进入死信队列根据id查询订单状态

->查询订单状态有没有修改，没有修改成已支付，就经行回滚积分、redis中信号量等操作

-> 5分钟未支付前台先自动关闭支付页面不能继续支付，同步调用一个取消订单的接口查询数据库中的订单支付状态为未支付就返回一个取消支付成功的状态,前台收到这个状态就判断当前按钮有没有置灰,置灰的话就取消置灰状态可以继续抢购

->之后调用支付宝接口定时查看支付状态-> 把支付了却没有修改订单状态的用户修改成已支付

->活动结束根据信号量数值同步修改数据库库存(保证库存的最终一致性)

 

**项目缺点**：强依赖redis，

解决方案：使用备用系统，redis宕机之后首先会使用rdb和aof进行混合持久化，然后将持久化的数据覆盖到我备用系统的redis服务器中，让程序可以使用新的redis继续执行





## 订单及支付：

集成的什么支付接口：企业支付宝

### 集成支付宝一般会提交哪些参数？  

答：8个核心参数必须提交 appid，公钥，私钥，订单编号，订单名称，价钱，异步回调地址，同步回调地址，非必须参数：订单描述，超时收单（timeout_express）(秒杀异步1分钟，电商一般为24小时)

在用户支付钱的时候支付已经完成了，要么给用户设计余额，要么使用支付宝支付扣减用户

订单支付成功后修改订单状态，然后给服务端发送消息告诉后台支付成功

### 什么是回调： 

支付宝机器人根据我们的回调地址（异步地址），进行回调。

同步回调异步回调都是支付宝的方法，然后支付成功后将支付包执行回调将参数回调给我们同时还多了几个参数像开始，结束的时间等

支付宝除了支付接口，还有反查接口，之前还有分润接口

### 如果支付成功，在回调的时候我们这边服务宕机或者网络中断，那么这个问题怎么解决？

  答：支付宝会在24小内主动回调8次，频率 刚开始时间短，后面时间比较长，3 5,10 30 1小时....。最大努力通知的方式。  

回调8次也失败了怎么办？答：我们这边可以调用查询接口，参数为订单号，如果是已经付款的，修改为已付款状态，具体怎么实现，订单后面加个按钮，或者使用定时器触发，对未付款订单进行查询是否已经付款。

### 什么是通知?

 答：通知，是支付宝回调我们服务器，我们服务器接受到请求后，已经修改为订单状态为已经付款后，给支付宝发送的一个字符串“success”，这个就是通知，作用是，支付宝收到了这个订单的success后，就不会继续后面的回调了。其它的支付接口一般用“ok”

### 什么是验签？

答：支付宝给我提供的一个sdk的方法，判断，回调回来的请求地址是否是支付宝回调的，如果不是支付宝回调的，不能修改订单状态。

![img](lu152441l02jn_tmp_d3c8aa348c3c2527.png) 

订单支付完成后 修改订单状态 积分添加等这些操作，（用户余额扣减在之前用户支付的时候就执行了）

## 秒杀(抢购，限时抢购，低价热卖)

### 秒杀高并发优化：

数据库设计：

  管理原来电商平台的商品表，我们这里创建一个秒杀活动表，一张秒杀获得和商品的中间表，他们之间的表关系为（商品表-秒杀活动表 多对多关系）， 秒杀活动表的字段：id，秒杀活动名称，秒杀活动开始和结束时间，秒杀活动介绍。 中间表：主键id，商品id，秒杀活动id，秒杀价钱（少于原价钱），秒杀库存（少于原库存），限购数量，是否包邮 。

秒杀模块开发，一般是一个独立的微服务，秒杀服务创建订单一般会调用订单服务。

#### 秒杀优化解决超买超卖：

1  秒杀列表页面，秒杀详情页面，秒杀库存（set，信号量） ，存放redis，减少数据库交互

2  超卖问题解决：秒杀创建订单：方式1 ，使用redisson分布式锁来实现，

createOrder1（）{ //这个是秒杀项目（微服务）的方法   

   //1 加锁 Object  lock = RedissonClient.getLock(“abc”); lock .lock() ；

​     Try(){

   //2 判断redis 库存是否大于零，如果大于零，减少1，减少成功

​      Message={orderId，商品id，用户id，秒杀活动id，价钱，订单名称}

​     Rabbit.sennder(message)；//可以用点对点（简单队列模式）

​     //使用消息队列进行数据库的削峰，数据库默认的qps 2000个左右，我们需要消息队列控制请求的释放数量，每秒1800个

  // 3. 尝试加锁，最多等待3秒，上锁以后10秒自动解锁
     boolean res = lock.tryLock(3, 10, TimeUnit.SECONDS);

}catch(){}finally{

   //3  释放锁  lock.unlock();

}

}  

分布式锁死锁和锁过期解决： 这个redisson的底层实现原理。

//上面的这个服务宕机导致死锁，finally也不能执行。

//加过期时间，也就是有效期，比如时20ms

// 如果执行时间小于20ms，挺好没有任何问题，如果方法执行时间大于20ms，锁提前过期，相当于锁无效，继续发生超卖。

//基于上我们可以使用守护线程（看门狗），线程里面添加一个定时器Timer，定时3ms执行一次，对锁有效期重置为20ms。 守护线程特点，主线程执行结束它跟着消亡

//以上解决了 死锁和锁提前过期的问题。

 //----------------------------------------------------

如果redis是集群：

redis集群（注意使用分布式锁的时候，多台reids服务器，要一起加锁成功，或者一起失败，）

服务器1 ，服务器2 ，服务器3

lock1 =Redisson.getLock(“a”).lock();

Lock2 =Redisson.getLock(“a”).lock();

Lock3 =Redisson.getLock(“a”).lock();

Boolean flag = RedissonRedLock（lock1，lock2，lock3）

 添加红锁的时候三个节点必须同时加上锁如果有一个没有加锁成功那就一起回滚重新加锁

节点过半原则：如果有多个节点，只有在大多数节点上获取到了锁，而且总的获取时间小于锁的超时时间的情况下，认为锁获取成功了。

## 异步编排

@Listener

@Globle transactionnal （seata）

createOrder2（ message）{ //这个是订单项目（微服务）的方法

​      创建线程池   ThreadPoolExecutor  

​      引用线程池对象  

//supplyAsync   有返回值线程池

CompletableFuture.supplyAsync（（）→{},线程对象）.whenComplete  

((result,exception)->{

​            CompletableFuture.runAsync（（）→{},线程对象）

​        })  

CompletableFuture.allOf(future, future1);//保证异步编排全部执行完12

   //异步1 （异步编排，使用到了线程池）

​    //1 减少库存 ，可以操作数据库了。

​    //2 创建订单（依赖减少库存），创建到数据库里面，同时把他更新到缓存。

  //异步2

​    //3 扣减积分

  //异步3

​    //4 扣减优惠券

  //异步4

​    //5 发送消息到延迟队列（准备对不付款的订单，加回库存）

​    上面这个对应一大段话术：如下:

// 确定上面异步全部做完了

 Alloff（）.get();

Return true;

 }

延迟队列：

 没付款的订单库存加回去（信号量）， 贵的商品低价卖的商品：热卖，货少的商品，一般针对秒杀的这些商品

 没有使用信号量之前：

### 定时器，为什么不用定时器了

1 时效性不高： 1分钟必须的把订单加回去，创建了59秒没付款，判断你不够一分钟，等下一分钟1分钟+59秒。

2 数据库负载太大： 1订单表全表查询超过1分钟未付款的订单，2 把这些订单状态设置关闭或失效，3 把库存加回去。

 消息队列延迟队列实现：

 ![img](lu152441l02jn_tmp_f02269cb2f49a389.png) 

//---------------------------------------------------------------------

超卖的另一种解决方式：继续优化：    

createOrder1（）{ //这个是秒杀项目（微服务）的方法   

​     Park = Redissonclient.getSemaphore(“miaosha”+“秒杀活动id+秒杀商品id”);

//下面这个方法相当于就是减去1个，减成功返回1，可以设置参数一次减少多个

 boolean b = park.TryAcquire();//这个如果超时（默认时间100ms），立刻停止等待

If(b){ //true ，说明上面建少1成功

  Rabbit.sender(Messagejson)   

 }

   }

}  

信号量没有获取锁的过程  立刻返回结果 可以批量的操作  

.TryAcquire 的方法去减信号量  也就是减库存

.getSemaphore 的方法获取信号量对象

.getrelease 刷新信号量

//-----------------------

没有使用锁之前，数据库的超买问题：

 超买问题（幂等问题）：条件：一个人只能限购一个，但是买成了多个（快速点击多次创建订单按钮），

   是数据库的唯一索引，我们这里使用联合唯一索引（用户id+秒杀商品id+秒杀活动id）

### 雪花算法优点：

算法简单，效率高，分布式下不重复，有序

## 接口安全：

### 1秒杀接口地址隐藏（防止恶意刷单）(1天)

 答： 秒杀没有开始之前，这个秒杀地址是不存在的。

​     秒杀开始了，按钮可以点击了，在点击按钮的时候才生成秒杀地址，而且这个秒杀地址是有有效期的，比如20秒。

实现方式1  

Ajax{  //拼接地址的方式

  1 生成一个地址  path= getPath()//uuid ，保存到redis 有效期20秒

  Ajax 2 正式提交表单  url=/miaosha/{path}/doMiaosha(){

​     }

 }

实现方式2

 //-----------------------

Ajax{  //拼接地址的方式

  1 生成一个地址  uuid= getUUid()//uuid （miaoshaToken），保存到redis 有效期20秒

  Ajax 2 正式提交表单  url=/miaosha/doMiaosha( uuid){

 }

 }

 //---------------------------------------------------------------------

### 2接口防刷（指定用户防刷）（防止接口恶意攻击导致服务宕机），接口限流（全局）  

答：1口防刷（指定用户防刷） ： 指定某个接口，比如秒杀接口，set（用户id+秒杀活动id+秒杀商品id 作为key，nummber）

5秒只能访问5次 ，key的有效期是5秒，nummber值不能大于

可选：封装成一个通用的功能，针对指定的接口加上一个注解 @ abc（3,6）  

2.2接口限流（全局）：使用setinel 设置一下接口访问次数（4500），设置的标准，参考jmeter压测的结果（错误率低于5%，对应的qps量 5000）

### Warm Up（预热）

秒杀系统中会有`预热`这样的流控设置，为了防止秒杀瞬间造成系统崩溃。 根据`codeFactor`（冷加载因子，默认3）的值，请求`QPS`从阈值/codeFacotor开始，经`预热时长`逐渐升至设定的`QPS`阈值。  

 //-----------------------------------------------------------

### 3 数字运算验证码（消峰能很强的）

  答： 可以网上搜一个数字验证码工具（加减乘除）代码，生成一个计算表达式（3+9x5）=48,这个48的结果可以保存到redis，key值可以使用用户id。 3+9x5  这个是个图片，前台显示

## 裂变分销

分销

会有级别

普通会员，分销会员

张三已经是分销商了：

一级：10%

二级：10%

三级：10%

张三（1000元） --》李四（1000元）--》王五（1000元）--赵六（1000元）--田七1000元

张三：100元，100元，100元，田七就没关系了。

李四：王五100，赵六100 ，田七100

王五：赵六100，田七100

田七：赶快去做推广

//--------------------------------------------

张三：（这里没有计算有大咖的出现）

一级：100元10 10次复销=1000元 1w

二级：100元10 10=10000元   10次复销  10w

三级：100元101010=100000元  10次复销 100w

//这里是已经不合法

四级：100元10101010=100w  10次复销  1000w

用户表：多一个字段父id，余额 （设置满200元可以提现）

提现收款表：默认收款类型shoutype ,1支付宝收款账号（邮箱账号或者手机号），2微信收款账号，3银行卡号 ，支行名称

提现明细表：每申请一次体现，这里独有一条数据，也有体现状态。

商品表：多三个字段对应一级，二级，三级的比例。

订单表：原来订单表没有任何的变化

记录佣金明细的表：主键id，订单编号（外键），收款人id，购买人id ，订单名称（冗余字段），佣金，是否提现（状态） ，付款状态

//后台

//前台

一个注册完成后，没有父id的， 张三

张三，有个一邀请链接url ，url 加一个 id 参数  

其他访问这个地址时候，自动填充父亲

或者用户注册的时候，给他一个邀请码（id）

注册完后就建立了绑定关系。

//--

用户，选择好对应的商品，购买商品，下订单，1生成订单 ，2生成多条佣金明细（1-3条）。付款，回调的订单状态修改方法：1 修改订单状态为已经付款，2 佣金的状态（1-3条）。

用申请提现，满200元提现。张三申请提现，看到20条佣金明细，申请完提前，全部变成已提现状态，资金累加到余额

。

开发出上面的这些业务就可以了

//-----------------------------------------------------

附加讲解：

用户：

划分：普通用户，用户vip1 （京东plush）  用户vip2  ，用户vip3 （最早电商平台用户名称划分）

   是否为分销商： 普通用 ，分销商

//-------------------------------

分销商级别

| 铜牌分销商（1000元） | 银牌分销商（5000） | 金牌分销商（30000） |      |
| -------------------- | ------------------ | ------------------- | ---- |
| 10%                  | 12%                | 15%                 |      |
| 10%                  | 12%                | 15%                 |      |
| 10%                  | 12%                | 15%                 |      |

升级后会产生有效期:收益比如月超过阈值 10万，那么金牌分销商30天进入倒计时，产生复购。 达到源源不断，生生不息。

## 砍价

小组内讨论数据库设计

话术：商品表对应 砍价活动表 关系为一对多关系，也就是一次砍价活动只关联一种商品，

 后台发布砍价活动，指定活动名称，活动时间段，限购数量，一般是一件，设定砍价成功的价钱（低价），设定砍价规则（算法），共多少刀看到低价，或者每刀最多砍价多少，直到砍到低价。主要是这个算法。

前台用户，发起砍价，砍完第一刀，把链接转给朋友（带参数），继续完成砍价。

## 会员中心

普通用户，消费到指定的金额，可以升级为指定会员，比如vip1，vip2，vip3 （level） ，消费越多级别越高，或者或花钱购买会员，会员可以设置有效期，不同级别的会员可以享受不同的折扣，比如9.9折，9.8折，9.5折等等，不同的会员可以参与各种营销活动的资格，比如秒杀，优惠券，大转盘，拼团，砍价，都可能指定那些级别的会员参与。

## 优惠券

数据模型关系：

商品表（原电商平台表）--  优惠券活动表关系，是一个多对多关系

用户表（原电商平台前台注册用户）---优惠券活动表 ，多对多关系

具体业务实现：

 CreateOrder（）{

   //1 减少库存

   //2 判断是否为会员，会员就优惠价钱

   //3 判断当前用户是否有优惠券，扣减优惠价钱

   //4 创建订单

}

话术：

话术整理：

   数据库设计：

​    商品表（原电商平台表）--  优惠券活动表关系，是一个多对多关系

用户表（原电商平台前台注册用户）---优惠券活动表 ，多对多关系

优惠券活动表：优惠券名称，发放数量，面值，使用说明，开始时间，结束时间，使用条件（满多少钱可以使用），限领条件（一个id可以领取1个或者几个），是否设置指定会员群里领取（默认所有用户可以领取），指定那些商品可以使用（默认是全部商品），一般情况我们会指定商品。 优惠券一般会在指定的商品的详情页面展示出来，再购物车页面在优惠券频道页面都可以看到这个优惠券，用户中心里面有个卡券可以看懂自己现在拥有那些优惠券。

## web服务器：

//---

Tomcat (web应用服务器)  ,

nginx/apache（web服务器）,为文件服务器nginx是tomcat的10倍以上

//--------------------------------------

域名解析（设置A解析，解析到一个ip地址：193.239.20.201）-->（病毒防御硬件服务器，绿盟科技）nginx -->指定到不同端口的tomcat路径（可能是经过gateway路由过的路径）,应用服务器（订单服务）--》数据库（数据库集群dba搭建）（一个数据库的访问地址，会自动路由到不同的分片上）--》灾难备份 ,第三方服务帮我们去做（赛门铁克）（不同的机房，不同的城市，中国三条线）(增量备份（日，周，月），全量备份（定期全量备份）)



## Cookie欺骗：

Cookies欺骗是通过盗取、修改、伪造Cookies的内容来欺骗Web系统,并得到相应权限或者进行相应权限操作的一种攻击方式  

怎么解决，用不良手段，获取cookie后，在后台进行cookie的身份验证，鉴定是不是真实用户，不是的话就不能获取具体的用户信息

## 旧服务和新服务之间是怎么进行数据迁移的

旧服务和新服务之间表结构不变,然后设立服务集群,等不忙的时候进行数据同步

## 秒杀前台怎么知道后台没库存了?

秒杀使用信号量扣减完之后,返回前台一个数,前台判断如果返回这个数,按钮置灰,没有支付的用户回滚

## 回滚完之后按钮还恢复吗?  

恢复,判断没有下单的用户不让他再次进行购买,数据回滚使用私信队列加个返回值前台通过返回值把按钮恢复,并且每次回滚让信号量加一,

bug :不恢复的话,假如有五十个恶意用户,同时秒杀这个商品却不支付,商品是不是就卖不出去了? 

