---
title: 西门子PLC基础
typora-root-url: 西门子PLC基础
keywords: '西门子,PLC'
tags: 西门子PLC
categories: 西门子PLC
description: 西门子PLC基础 TIA博途S7-1200学习笔记
abbrlink: a5a5d18
date: 2024-08-17 12:42:44
photos:
---

西门子PLC基础 TIA博途S7-1200学习笔记

<!--more-->

------

PLC(Programmable Logic Controller)控制系统，即可编程逻辑控制器，是专为工业生产和控制而设计的一种**数字运算**操作的电子装置，并采用可编程的存储器，用于其内部存储程序，执行**逻辑运算，顺序控制，定时，计数与数据处理**等面向用户的指令，并通过**数字或模拟式输入/输出端口**控制各种类型的机电设备或生产过程，是工业控制的核心部分。

## PLC控制系统

主要分为：

​	上位机 : 监控设备状态控制设备 例PC或触摸屏
​	控制系统 ：对现场设备进行控制，记录现场运行数据，将现场设备运行状态传送至上位机
​	执行装置 ：电动机为执行装置，负责执行PLC发出的指令，完成生产

## 基本结构与工作原理

### 简介：

SIMATIC S7-1200是西门子公司的一款紧凑型、模块化的PLC，可完成简单与高级逻辑控制、触摸屏(HMI)网络通信等任务。对于需要网络通信功能和单屏或多屏HMI的自动化系统，易于设计和实施。具有支持小型运动控制系统、过程控制系统的高级应用功能。
1200系列PLC的CPU 将微处理器、集成电源、输入和输出电路、内置PROFINET、高速运动控制 I/O以及板载模拟量输入组合到一个设计紧凑的外壳中来形成功能强大的控制器。

### CPU：

S7-1200 系列CPU有五种不同型号的模块，分别为CPU1211C、CPU1212C、CPU 1214C、CPU1215C和CPU1217C。每一种模块都可以进行扩展，以满足用户系统需要。用户可以在任何型号的CPU 前方加入一个信号板，用来扩展数字量或模拟量 I/O，同时不影响控制器的实际大小，也可将信号模块连接至 CPU 的右侧以进一步扩展数字量或模拟量 I/0 的容量。

![](CPU.png)

#### 组成：

#### cpu模块

1 电源接口;
2 存储卡插槽(上保护盖下面):
3 可拆卸用户接线端子;
4 板载I/0状态指示LED;
5 PROFINET连接端口(CPU的底部)。

该CPU提供一个PROFINET端口用于与其他模块进行PROFINET网络通信。还可以使用附加模块通过PROFIBUS、RS485、RS232、GPRS、IEC等协议进行网络通信。电源接口用于给CPU提供24V直流电，存储卡可以作为CPU的预装载存储区，用户项目文件仅存储在卡中，CPU中没有项目文件离开存储卡将无法运行;忘记密码时，清除CPU内部项目文件和密码;存储卡还可以用于更新S7-1200CPU的固件版本(只限24M卡)。接线端子用于PLC与外部设备进行数字或模拟通讯:PROFINET连接端口用于PLC与外部设备以及编程计算机进行总线通讯。

#### 信号模块：

信号模块又称为SM模块(Signal Module)包括数字量输入模块(DI)、输出模块(DO)和模拟量输入模块(AI)、输出模块(AO)

输入模块用于采集和接收输入信号，数字量输入模块(DI)用于接收开关、按钮、限位开关、光电开关、继电器等过来的数字量输入信号;模拟量输入模块(AI)用于接收电位器，温度传感器，测速发电机，压力传感器等提供连续变化的模拟量信号。

输出模块用于控制外部设备。数字量输出模块(DO)用于控制接触器、继电器指示灯、电磁阀等数字量控制外设:模拟量输出模块(AO)可用于控制变频器、压力阀等模拟量控制的外设。

#### 通信模块：

![](通信模块.png)

通信模块（CB）安装在CPU模块的左边，最多可以添加三块通信模块，可以使用点对点通信模块、RPOFIBUS模块、AS-i接口模块和IO-Link模块等



#### CPU接线图

![](cpu接线.png)

其中，24V DC传感器电源输出要获得更好的抗噪声效果，即使未使用传感器电源也可将“M”连接到机壳接地。对于漏型（低电平）输入，将“_”连接到“M”(如图所示)对于源型（高电平）输入，将“+”连接到“M'



#### PLC的工作过程

##### CPU的工作模式

​	CPU有3种工作模式:RUN(运行)、STOP(停机)和STARTUP(启动)面板上的状态LED用来显示当前的控制模式，可以用编程软件改变CPU的工作模式,STOP模式下，CPU只处理通信请求和进行自诊断，不执行用户程序，不更新过程映像。上电后CPU进入STARTUP(启动)模式，进行上电诊断和系统初始化，如果检查到错误，将禁止CPU进入RUN模式，保持在STOP模式，指示灯会变成红色，且闪。

##### 工作模式的切换

1200系列CPU模块上没有切换工作模式的选择开关，只能用STEP7变成软件在线工具中的CPU操作面板。或者工具栏上的![](启动1.png)和 ![](停止2.png) 按钮，来切换RUN或者STOP工作模式，也可在用户程序中用STP指令让CPU进入STOP模式。



##### 冷启动与暖启动

​	下载了用户程序的程序块和硬件组态后，下一次切换到RUN模式时，CPU会执行冷启动。冷启动时复位输入，初始化输出，复位存储器，即清除工作存储器、非保持性存储区和保持性存储区的数据，并将装载存储器的内容复制到工作存储器。存储器复位不会清除诊断缓冲区，也不会清除永久保存的IP地址

​	冷启动之后，在下一次下载程序之前的STOP到RUN模式的切换均为暖启动。暖启动时，所有费保持性的系统数据和用户数据被初始化，不会清除保持性存储区的数据。





## 编程方式：

### 梯形图

![](梯形自锁程序.png)

逻辑用梯形图

### 功能块图

​	功能块图(FBD)使用类似于数字电路的图形逻辑符号来表示控制逻辑，几乎没人用

​	用鼠标右键点击'MAIN(OB1)”，找到“切换编程语言”，选择“FBD”

### SCL语言

![](SCL语言案例.png)

​	数据处理用SCL

​	SCL(Structured Control Language，结构化控制语言)是一种基于PASCAL的高级编程语言。SCL除了包含PLC的典型元素(例如输入、输出、定时器等)外，还包含高级编程语言中的表达式、运算符和赋值运算。SCL提供了简便的指令进行程序控制如创建程序分支、循环或跳转。SCL主要适用于以下领域:数据处理、过程优化、数学运算和统计任务等。

## 系统存储区：

### PLC选择的物理存储器

1)只读存储器(ROM)。只读存储器只能读出，不能写入，**是非易失性存储器电源中断也不会造成数据的丢失，一般用来存放PLC的操作系统**。

2)随机存储器(RAM)。CPU可以从存储器读出数据或者向存储器写入数据，**是易失性存储器，电源中断后，存储器的数据丢失**:

3)快闪存储器(FLASH EPROM)和电擦除存储器(EEPROM)**是非易失性存储器，用来存放用户程序和断电时需要保护的重要数据**。

### 装载存储器

装载存储器用于非易失性的存储用户程序、数据和组态信息，能够在断电后继续保持，该存储区位于存储卡(如果有)或者CPU中。项目被下载到CPU后，首先存储在装在存储区中。

### 工作存储器

工作存储器是易失性存储器，用于在执行用户程序时存储用户项目的某些内容。CPU会将一些项目内容从装载存储区复制到工作存储区中，该存储区在断电后丢失，在回复供电时由CPU恢复。

### 断电保持存储器

保持存储器用于在断电时存储所选用户存储单元的值。断电发生时，CPU留出了足够的缓冲时间来保存几个有限的指定单元的值，这些被保持的值会在下次供电时恢复。暖启动后，断电保持存储器中的数据保持不变，冷启动时断电保持存储器的值会被清除。

存储卡
可选的SIMATIC存储卡可用作存储用户程序的替代存储器，或用于传送程序，如果使用存储卡，CPU将运行存储卡中的程序，而不是自身存储器中的程序。(CPU仅支持预先已格式化的存储卡。存储卡保护开关要离开“LOCK”位置，关掉写保护功能。存储卡可将项目复制到多个CPU中，传送卡将存储的项目从卡中复制到CPU的存储器后必须取出存储卡。存储卡作为程序卡使用时，可以替代CPU存储器，所有CPU功能都由该程序卡进行控制，插入程序卡会擦出CPU内部装载存储器的所有内容(包括用户程序和任何强制I/0)，然后**CPU会执行程序卡中的用户程序，程序卡必须保留在CPU中，如果取出，CPU必须切换到STOP模式**。

## 基本数据类型：

数据类型组中定义有数据的属性，例如：内容及有效存储区的表示。

在用户程序中，可使用预定义的数据类型，并将这些数据类型添加到用户自定义数据类型中。此时，可使用以下类别：

基本数据类型（二进制数、整数、浮点数、定时器、DATE、TOD、LTOD、CHAR、WCHAR）

复杂数据类型（DT、LDT、DTL、STRING、WSTRING、ARRAY、STRUCT）

用户自定义数据类型（PLC 数据类型 (UDT)）

指针

参数类型

系统数据类型

硬件数据类型
————————————————

| 数据符号      | 数据名称                                                     | 取值                                                         | 数值类型     | 应用范围                                                     | 输入示例                                      |
| ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------ | ------------------------------------------------------------ | --------------------------------------------- |
| BOOL          | 布尔，是表示1位的值                                          | 0或1                                                         | 二进制数     | 逻辑计算                                                     | TRUE，FALSE，0，1                             |
| BYTE          | 字节，是位字符串，占有8位                                    | 16#00—16#FF                                                  | 二进制数     | 逻辑计算                                                     | 16#12，16#AB                                  |
| WORD          | 字，是位字符串，占有16位                                     | 16#0—16#FFFF                                                 | 二进制数     | 逻辑计算                                                     | 16#ABCD，16#0001                              |
| DWORD         | 双字，是位字符串占有32位                                     | 16#0—16#FFFF FFFF                                            | 二进制数     | 逻辑计算                                                     | 16#02468ACE                                   |
| LWORD         | LWORD是一个64位的无符号整数，它可以存储64位的数据。          | ~                                                            | 二进制数     | 逻辑计算，如果你需要存储大量的位数据，使用LWORD将会很方便。  |                                               |
| Char          | 字符，占有8位                                                | ASCII 字符                                                   | 字符         |                                                              | 'A','@','t'                                   |
| WCHAR         | 宽字符，占有16位                                             | ASCII 字符                                                   | 字符         | WCHAR 数据类型将扩展字符集中的单个字符保存为 UFT-16 编码形式。 | WCHAR#‘A’                                     |
| STRING        |                                                              | ASCII 字符串，包括特殊字符                                   | 字符串       |                                                              | “name”                                        |
| SINT          | 有符号短整型，占有8位                                        | -128—127                                                     | 整型         | 数学计算                                                     | 123，-123                                     |
| USINT         | 无符号短整型，占有8位                                        | 0—255                                                        | 整型         | 数学计算                                                     | 123                                           |
| INT           | 有符号整型，占16位                                           | -32768—32767                                                 | 整型         | 数学计算                                                     | 123，-123                                     |
| UINT          | 无符号整型，占16位                                           | 0—65535                                                      | 整型         | 数学计算                                                     | 123                                           |
| DINT          | 有符号双整型，占32位                                         | -2,147,483,648—2,147,483,647                                 | 整型         | 数学计算                                                     | 123，-123                                     |
| UDINT         | 无符号双整型，占32位                                         | 0—4,294,967,295                                              | 整型         | 数学计算                                                     | 123                                           |
| LINT          | 有符号长整型，占有8位                                        | ~                                                            | 整型         | 数学计算                                                     | 123，-123                                     |
| ULINT         | 无符号长整型，占有8位                                        | ~                                                            | 整型         | 数学计算                                                     | 123                                           |
| Real          | 单精度浮点数，最多可以指定 6 位有效数字来保持精度，占有32 位 | 实数：+/-1.18x10∧－38到+/-3.40x10 ∧38                        | 浮点数       |                                                              | 123.456、-3.4、-1.2E+12、<br/>3.4E-3          |
| LReal         | 双精度浮点数，最多可以指定 15 位有效数字来保持精度，占有64 位 | 长实数：+1-2.23x10∧ -308 到 +/-1.79 x10 ∧308                 | 浮点数       |                                                              | 12345.123456789，-1.2E+40                     |
| Time          | 32                                                           | T#-24d 20h 31m 23s 648ms toT#24d 20h_31m_23s_647ms<br/>存储形式:-2,147,483,648 ms to+2.147.483.647 ms | 时间         |                                                              | T#5m_30s<br />5#-2d<br />T#1d_2h_15m_30x_45ms |
| String        | 变量                                                         | 0 到 254 字节字符 字符串                                     | 字符串       |                                                              | 'ABC'                                         |
| DTL∧1         | 12个字节                                                     | 最小值:DTL#1970-01-01-00:00:00.0最大值:DTL#2554-12-31-23:59:59.999 999999 | 日期         |                                                              | DTL#2008-12-16-20:30:20.250                   |
| Array（数组） |                                                              |                                                              | 复杂数据类型 |                                                              |                                               |

## 寄存器分类：

计算机内部都是以“0”、“1”二进制形式存储的，最小的存储单元位通常位一个字节（8个比特位：8bit），1bit位就是**存储元**（晶体管构成门电路，门电路构成锁存器或触发器，锁存器或触发器构成存储元）

一个字节存储单元

而根据CPU读写数据速度的不同，存储区域又可以划分为不同的存储区，相当于**居民小区**里有很多幢**居民楼**（进一步理解，可以将居民楼里的房间理解为**存储元**）,距离小区门口近的居民楼，进出小区自然是又快又方便。同理，距离CPU路程越近的存储区，其数据的访问速度也会越快，这块存储区我们称为**寄存器**，也是价格最贵的一块存储区。

PLC（可编程控制器）也是一个小型的计算机，它的CPU内部有用于PLC程序、数据和组态信息保存的**装载存储器**，有用于程序运行的工作存储器（相当于PC的运行内存RAM），有用于非易失性地存储限量的工作存储器值的保持性存储器。而用于用户程序在执行期间数据存储的地方称为数据存储区，这片存储区也是集成在CPU内部的，包括以下几大类：

| 存储区                      | 说明                                                         | 强制                     | 保持性 |
| --------------------------- | ------------------------------------------------------------ | ------------------------ | ------ |
| I 存储区<br/>(过程映像输入) | 在扫描周期开始时读取输入端子外围设备的“开”“关”的状态，将状态值写入到存储区 | 立即输入点<br />支持强制 | 无     |
| Q 存储区<br/>(过程映像输出) | PLC程序运算的输出值不会直接作用到输出端子的设备上，而是在扫描周期开始时先复制到Q存储区 | 立即输出点<br />支持强制 | 无     |
| M 存储器                    | 中间数据存储器，比如程序运算的一个中间值可以存到这里         | 无                       | 可选   |
| 临时存储器L                 | 存储块的临时数据，这些数据仅在该块的本地范围内有效           | 无                       | 无     |
| DB数据块                    | 数据存储器，同时也是FB(功能块)的参数存储器                   | 无                       | 可选   |

## 寻址方式:

程序在执行的过程中需要读写数据，而读写数据的第一步就是寻址（址：数据的地址，PLC中所有能访问的数据都有地址，就像每个人都有一个身份证一样），寻址方式分为：按位寻址、按字节寻址，按字寻址和按双字寻址

### 按位寻址

![](按位寻址.png)

按位寻址就是一次访问一个存储元的存储值，上图黑色存储元在Byte2字节Bit2位处，那么对他的寻址（访问）方式就是**M2.2**，“M”表示存储器的标识符，第一个“2”表示字节号，第二个“2”表示位号。

### 按字节寻址

![](按字节寻址.png)

按字节寻址就是一次访问或者读写一个字节大小（8个bit位）的存储区，上图中绿色区域为Byte3，对他的寻址就是**MB3**，“M”表示存储器的标识符，“B”表示为按字（Byte）节寻址，“3”表示字节号。

### 按字寻址

![](按字寻址.png)

按字寻址就是一次访问或者读写2个字节（16个bit位），上图中绿色和蓝色存储区的寻址方式分别位MW1和MW5，“M”表示存储器的标识符，“W”表示为按字（Word）寻址，“1”和“5”表示字节号。

### 按双字寻址

![](按双字寻址.png)

按双字寻址就是一次访问或者读写4个字节（32个bit位）的数据，上图中绿色和蓝色区域的寻址方式分别位MD0和MD4，“M”表示存储器的标识符，“D”表示为按双子（Double Word）寻址，“0”和“4”表示字节号

### 寻址案例：

![](寻址案例.png)

程序运行时，每个扫描周期都会对I和Q存储器寻址，比如，当IO.0寻址的值为“1”，则常开触点闭合，若此时急停按钮时闭合的（急停按钮一般是一对常闭触点），则输出线圈Q0.0闭合，Q存储器0字节0位这个存储元就被写入“1”，这个存储元的“1”值会在下一个扫描周期开始时将PLC的Q0.0这个输出端子接通，KM接触器线圈得电，主电路接通，电机工作。

## 程序块及类别

![](程序块.png)

在PLC的编程中，**程序块**是指一组逻辑控制代码，用于实现系统中特定的控制功能。程序块主要分为四类，包括函数块（FB）、函数（FC）、数据块（DB）和组织块（OB）四种类型。不严谨的说，组织块（OB）可以相当于主程序，函数块（FB）和函数（FC）可以相当于子程序，数据块（DB）可以相当于数据存储区。



关心数据FB

不关心数据FC

全局数据块DB

OB主程序不能被其他系统调用



### 函数块（FB）

![](函数块.png)



描述：函数块是用户编写的包含经常使用的功能的子程序，其含有专用的背景数据块。
由于运行过程中需要调用各种参数，因此产生了背景数据块DB，所以需要用到的数据就存储在了DB中。即使结束调用，数据也不丢失。

函数块（Function Block）是PLC编程中最常用的程序块类型。它类似于面向对象编程中的类，用于封装特定的控制逻辑，并将其作为一个整体进行调用和重复使用。函数块可以由多个输入和输出组成，它们的功能通常与具体的硬件设备相关。例如，一个函数块可以用来控制一个电机，另一个函数块可以用来实现温度控制。函数块通常由多个网络组成，每个网络包含了一个或多个指令，它们共同实现函数块的控制逻辑。一个函数块可以被多个程序或函数调用，这使得程序的编写变得更加高效和简单。

CPU执行FB中的程序，将块的输入输出参数和局部静态变量保存在背景数据块中，以便在后面的扫描周期访问它们。FB的典型应用是执行不能再一个扫描周期完成的操作。在调用FB时，会自动打开对应的背景数据块，数据块中的变量可以供其他代码块使用。

### 函数（FC）

![](函数.png)

函数也是用户编写的包含经常使用的功能的子程序。

函数（Function）与函数块非常相似，但它只包含一个网络，通常用于实现简单的控制逻辑。与函数块不同的是，FC无专用的背景数据块，函数（FC）在运行时产生的临时变量保存在全局数据块DB中，函数没有输入和输出参数，它只是将数据作为参数进行处理，然后返回处理结果，执行结束后，数据将丢失，不具备存储功能。函数通常用于实现一些通用的算法，例如加减乘除、求平方根、三角函数等。

可以在程序的不同位置多次调用同一个FC或FB块，这样可以简化重复执行的任务编程。

### 数据块（DB）

![](数据块.png)

数据块（Data Block）是PLC编程中用于存储和管理数据的程序块类型。数据块可以包含各种数据类型，例如整型、浮点型、字符型等。在程序中，可以通过数据块来读取和写入变量的值。数据块通常用于存储程序的输入、输出、状态等数据，也可以用于存储程序运行过程中的临时变量。数据块可以在程序块之间共享，这使得程序的编写变得更加高效和简单。例如，如果多个函数块需要共享一个变量，可以将这个变量定义为一个数据块，并在函数块中引用它。

数据块分为背景数据块和全局数据块两种。
背景数据块是专门用于保存函数块（FB）中的输入变量，输出变量和静态变量的。其中的数据在编译时自动生成。FB的临时数据不是用背景数据块保存的。
全局数据块是一片存储用户数据的区域，供所有的代码块访问，所有的OB、FB和FC都可以访问，全局数据块也被称为共享数据块.

创建好数据块要看偏移量，需要右击数据块，取消优化的块访问，再编译下项目就可以看到偏移量

### 组织块（OB）

![](组织块.png)

组织块（Organization Block）是PLC编程中用于管理程序运行的程序块类型。组织块可以控制程序的执行顺序、周期、中断等。在程序中，通常需要定义一个或多个组织块来实现程序的运行和控制。组织块是CPU操作系统与用户程序的接口，决定了用户的程序结构。组织块将自动被操作系统调用。
使用中有中断组织块，启动组织块等。
使用时必须有OB1组织块，操作系统每个扫描周期执行一次OB1。

组织块通常由多个网络组成，每个网络包含了一个或多个指令，它们共同实现组织块的控制逻辑。组织块可以被编译成PLC的内部指令，以便在PLC运行时进行执行。在程序中，通常需要将组织块与输入和输出绑定，以便实现程序的运行和控制。

在PLC编程中，组织块可以分为多种类型，例如主程序（Main Program）、子程序（Subroutine）、中断（Interrupt）、异常（Exception）等。每种类型的组织块都有其独特的用途和应用场景，可以根据需要选择适合的类型。

每个组织块必须有唯一的编号，123号之前的一些编号是保留的，其他OB的编号应大于等于123。0B块不能互相调用，也不能被FC和FB块调用，只有启动事件(如周期性中断事件或诊断中断事件)可以启动OB块的执行。OB1是用户程序中的主程序，在每一次循环中，操作系统程序调用一次0B1，因此0B1中的程序时循环执行的。一个PLC程序中允许有多个程序循环，默认的块是OB1，其他的循环程序OB的编号必须大于等于123



### 程序块作用：

函数块和函数用于实现控制逻辑，数据块用于存储和管理数据，组织块用于管理程序的执行顺序、周期、中断等。



程序块的使用可以**使PLC程序的编写变得更加高效和简单**。

通过使用程序块，**可以将复杂的控制逻辑封装为一个整体，实现代码的重复使用和共享**。

程序块也可以**提高程序的可读性和可维护性，降低程序的出错率**。

### 程序块的选择：

在PLC编程中，**需要根据具体的应用场景选择适合的程序块**类型。

​	例如，
​	如果需要实现电机控制，可以选择函数块；
​	如果需要实现通用的算法，可以选择函数；
​	如果需要存储和管理数据，可以选择数据块；
​	如果需要管理程序的执行顺序、周期、中断等，可以选择组织块。

## 指令集

以串联方式连接的触点创建与（AND）逻辑程序段。以并联方式连接的触点创建或（OR）逻辑程序段。 可将触点相互连接并创建用户自己的组合逻辑。如果用户指定的输入位使用存储器标识符I（输入）或Q（输出），则从过程映像寄存器中读取位值。

控制过程中的物理触点信号会连接到PLC上的I端子。CPU扫描已连接的输入信号并持续更新过程映像输入寄存器中的相应状态值。

通过在I偏移量后加入“:P”，可指定立即读取物理输入（例如：“%I3.4:P”）

通过在Q偏移量后加入“:P”，可指定立即写入物理输出。对于立即写入，将位数据值写入过程映像输出寄存器并直接写入物理输出。

### 1 位逻辑运算操作

![](位逻辑指令.png)



1.1 常开触点
**—| |—**

1为OFF，0为ON。

1.2 常闭触点
**—|/|—**

1为ON，0为OFF。

1.3 取反触点
**—|NOT|—**
输入为0，输出为1，输入为1输出为0；

1.4 线圈
**—( )—**
1.5 赋值取反
**—( / )—**
将逻辑运算的结果进行取反，然后将其赋值给这个线圈的操作数。

1.6 复位输出
**—( R )—**
1.7 置位输出
**—( S )—**
1.8 置位位域
**—( SET_BF )—**
1.9 复位位域
**—( RESET_BF )—**
1.10 SR置位/复位触发器

![](SR置位_复位触发器.png)

| 参数 | 说明               |
| ---- | ------------------ |
| S    | 使能置位           |
| RI   | 使能复位，复位优先 |
| SR   | 待使能操作数       |
| Q    | 操作数信号状态     |

SR置位/复位触发器-信号真值表

| S    | RI   | Q    |
| ---- | ---- | ---- |
| 0    | 0    | 保持 |
| 0    | 1    | 复位 |
| 1    | 0    | 置位 |
| 1    | 1    | 复位 |

​		

1.11 RS复位/置位触发器

![](RS复位_置位触发器.png)

| 参数 | 说明               |
| ---- | ------------------ |
| R    | 使能复位           |
| SI   | 使能置位，置位优先 |
| SR   | 待使能操作数       |
| Q    | 操作数信号状态     |

RS复位/置位触发器-信号真值表

| SI   | R    | Q    |
| ---- | ---- | ---- |
| 0    | 0    | 保持 |
| 0    | 1    | 复位 |
| 1    | 0    | 置位 |
| 1    | 1    | 置位 |

1.12 扫描操作数的信号上升沿
**—| P |—**
检测到信号上升沿时，操作数 1 的信号状态将在一个程序周期内保持置位为“1”。在其它任何情况下，操作数的信号状态均为“0”。

| 参数    | 说明                                 |
| ------- | ------------------------------------ |
| 操作数1 | 要扫描的信号                         |
| 操作数2 | 保存上一次查询的信号状态的边沿存储位 |

1.13 扫描操作数的信号下降沿
**—| N |—**
检测到信号下降沿时，操作数 1 的信号状态将在一个程序周期内保持置位为“1”。在其它任何情况下，操作数的信号状态均为“0

| 参数    | 说明                                 |
| ------- | ------------------------------------ |
| 操作数1 | 要扫描的信号                         |
| 操作数2 | 保存上一次查询的信号状态的边沿存储位 |

1.14 在信号上升沿置位操作数
**—( P )—**
当输入查询到上升沿时，操作数置位为1一个程序周期，然后其它时间全为0；

| 参数    | 说明               |
| ------- | ------------------ |
| 操作数1 | 上升沿置位的操作数 |
| 操作数2 | 边沿存储位         |

1.15 在信号下降沿置位操作数
**—( N )—**
当输入查询到下降沿时，操作数置位为1一个程序周期，然后其它时间全为0；

| 参数    | 说明               |
| ------- | ------------------ |
| 操作数1 | 下降沿置位的操作数 |
| 操作数2 | 边沿存储位         |

1.16 P_TRIG扫描 RLO 的信号上升沿

![]( P_TRIG扫描 RLO 的信号上升沿.png)

检测到信号上升沿时，该指令输出 Q 将立即返回程序代码长度的信号状态“1”。在其它任何情况下，该输出返回的信号状态均为“0”。

| 参数   | 说明                                 |
| ------ | ------------------------------------ |
| CLK    | 沿信号输入端，当前RLO                |
| 操作数 | 保存上一次查询的信号状态的边沿存储位 |
| Q      | 边沿检测结果                         |




1.17 N_TRIG扫描 RLO 的信号下降沿

![](N_TRIG扫描 RLO 的信号下降沿.png)

检测到信号下降沿时，该指令输出 Q 将立即返回程序代码长度的信号状态“1”。在其它任何情况下，该输出返回的信号状态均为“0”。

| 参数   | 说明                                 |
| ------ | ------------------------------------ |
| CLK    | 沿信号输入端，当前RLO                |
| 操作数 | 保存上一次查询的信号状态的边沿存储位 |
| Q      | 边沿检测结果                         |

1.18 R_TRIG检查信号上升沿

![](R_TRIG检查信号上升沿.png)

该指令将输入 CLK 的当前值与保存在指定实例中的上次查询（边沿存储位）的状态进行比较。如果该指令检测到输入 CLK 的状态从“0”变成了“1”，就会在输出 Q 中生成一个信号上升沿，输出的值将在一个循环周期内为 TRUE 或“1”。

| 参数 | 说明                         |
| ---- | ---------------------------- |
| EN   | 使能输入                     |
| ENO  | 使能输出                     |
| CLK  | 达到信号，将查询该信号的边沿 |
| Q    | 边沿检测的结果               |

1.19 F_TRIG：检查信号下降沿

![](F_TRIG：检查信号下降沿.png)

该指令将输入 CLK 的当前值与保存在指定实例中的上次查询（边沿存储位）的状态进行比较。如果该指令检测到输入 CLK 的状态从“1”变成了“0”，就会在输出 Q 中生成一个信号下降沿，输出的值将在一个循环周期内为 TRUE 或“1”。

| 参数 | 说明                         |
| ---- | ---------------------------- |
| EN   | 使能输入                     |
| ENO  | 使能输出                     |
| CLK  | 达到信号，将查询该信号的边沿 |
| Q    | 边沿检测的结果               |

1.20 四种沿信号的区别
1.20.1

![](1.20.1.png)

在P触点上面的I0.0的上升沿，该触点接通一个扫描周期。因此P触点用于检测触点上面的地址的上升沿，并且直接输出上升沿脉冲。其他3种指令都是用来检测逻辑运算结果RLO（即流入指令输入端的能流）的上升沿。

1.20.2

![](1.20.2.png)

在流过P线圈的能流的上升沿，线圈上面的地址Q0.1在一个扫描周期为1状态。因此P线圈用于检测能流的上升沿，并用线圈上面M2.2的触点来输出上升沿脉冲。其他3种指令都是直接输出检测结果。

1.20.3&4

![](1.20.3&4.png)

R_TRIG指令与P_TRIG指令都是用于检测流入它们的CLK端的能流的上升沿，并用Q端直接输出检测结果。其区别在于R_TRIG是函数块，用它的背景数据块DB3保存上一次扫描循环CLK端信号的状态，
而P_TRIG指令用边沿存储位M10.3来保存它。P 触点和P线圈分别用边沿存储位M10.0和M10.1来保存它们的输入信号的状态。

| 对比项目   | P触点    | P线圈    | P_TRIG   | R_TRIG     |
| ---------- | -------- | -------- | -------- | ---------- |
| 沿信号来源 | 靠自己   | 靠别人   | 靠别人   | 靠别人     |
| 输出脉冲   | 给别人   | 给自己   | 给别人   | 给别人     |
| 边沿存储   | 自己的位 | 自己的位 | 自己的位 | 背景数据块 |

### 2 定时器指令

IEC：国际电工委员会缩写，IEC定时器表示国际标准定时器。

2.1 TP 脉冲定时器

![](TP_脉冲定时器.png)

当 IN 端收到一个上升沿信号，Q开始输出能流并开始计时，当计时时间达到PT设定时间后，Q不再有能流输出，知道下有一个上升沿信号输入到IN端口。

| 参数 | 说明         |
| ---- | ------------ |
| IN   | 启动输入     |
| PT   | 脉冲持续时间 |
| Q    | 脉冲输出     |
| ET   | 当前时间值   |


2.2 TON 接通延时定时器

![](TON_接通延时定时器.png)

【延时接通，瞬时关断】当IN有能流输入时，且保持一直有，则TON 开始计时，当计时时间达到PT设定时间后，Q输出能流，且只要IN有能流输入，Q便一直有能流输出。

| 参数 | 说明                   |
| ---- | ---------------------- |
| IN   | 启动输入               |
| PT   | 接通延时持续时间       |
| Q    | 超过时间PT后置位的输出 |
| ET   | 当前时间值             |

2.3 TOF 关断延时定时器

![](TOF_关断延时定时器.png)

【瞬时接通，延时关断】当IN有能流输入时，Q输出能流，且只要IN有能流输入，Q便一直有能流输出；当IN从接通改为断开后，则TON 开始计时，此时Q仍有能流输出，当计时时间达到PT设定时间后，Q被复位。

| 参数 | 说明                   |
| ---- | ---------------------- |
| IN   | 启动输入               |
| PT   | 关断延时的持续时间     |
| Q    | 超过时间PT后复位的输出 |
| ET   | 当前时间值             |

2.5 TONR时间累加器定时器

![](TONR_时间累加器定时器.png)

描述： 当IN端接通时，TNOR开始计时，当IN断开时，TNOR停止计时，但当前计时时间不清零，下次IN再接通时计时时间累加，当累加计时时间达到PT设定值后，Q输出能流，此时无论IN 是否接通都不在影响Q输出能流。
当R收到一个上升沿信号时，TONR累计时间清零，Q被复位。

| 参数 | 说明                     |
| ---- | ------------------------ |
| IN   | 启动输入                 |
| R    | 复位输入                 |
| PT   | 时间记录最长持续时间     |
| Q    | 超过时间PT后要置位的输出 |
| ET   | 累计时间值               |

### 3 计数器指令

3.1 CTU 加计数器

![](CTU_加计数器.png)

描述： CU端每收到一个上升沿信号，CTU便做加一计数，当计数值累加到PV设定值后，Q有能力输出；当R端接收到一个上升沿信号后，Q输出复位，CTU计数清零。

| 参数 | 说明           |
| ---- | -------------- |
| CU   | 计数输入       |
| R    | 复位输入       |
| PV   | 置位输出Q的值  |
| Q    | 计数器状态     |
| CV   | 当前计数器的值 |


3.2 CTD 减计数器

![](CTD_减计数器.png)

描述： 程序刚启动时，当CD和LD都没有产生上升沿信号时，Q有能流输出；当LD收到一个上升沿信号，便将PV设定值装载到CTD计数器中，并且复位Q；每当CD收到一个上升沿信号时，CTD自减一，当减到0时，置位Q输出能流。

| 参数 | 说明           |
| ---- | -------------- |
| CD   | 计数输入       |
| LD   | 转载输入       |
| PV   | 装载的计数值   |
| Q    | 计数器状态     |
| CV   | 当前计数器的值 |

3.3 CTUD 加减计数器

![](CTUD_加减计数器.png)

| 参数 | 说明           |
| ---- | -------------- |
| CU   | 加计数输入     |
| CD   | 减计数输入     |
| R    | 复位输入       |
| LD   | 转载输入       |
| PV   | 装载的计数值   |
| QU   | 加计数器状态   |
| QD   | 减计数器状态   |
| CV   | 当前计数器的值 |

描述： cu让计数器自加一，CD让计数器自减一，R给计数器计数值清零，LD将PV的设定值装载到计数器；
计数器值对应的输出状态

| 数值范围 | QU   | QD   |
| -------- | ---- | ---- |
| (+∞,0]   | 0    | 1    |
| (0,PV)   | 0    | 0    |
| [PV,+∞)  | 1    | 0    |

### 4 比较指令

| 指令           | 描述         |
| -------------- | ------------ |
| CMP==          | 等于         |
| CMP<>          | 不等于       |
| CMP>=          | 大于等于     |
| CMP<=          | 小于等于     |
| CMP>           | 大于         |
| CMP<           | 小于         |
| IN_Range       | 值在范围内   |
| OUT_Range      | 值不在范围内 |
| —\| OK \|—     | 检查有效性   |
| —\| NOT OK \|— | 检查无效性   |


检查有效性指令和检查无效性指令只针对浮点数数据类型进行查验。

![](比较指令1.png)

![](比较指令2.png)

### 5 数学函数

| 指令      | 描述         | 指令  | 描述           |
| --------- | ------------ | ----- | -------------- |
| CALCULATE | 计算函数     | LIMIT | 设置限值       |
| ADD       | 加           | SQR   | 计算平方       |
| SUB       | 减           | SQRT  | 计算平方根     |
| MUL       | 乘           | LN    | 计算自然数对数 |
| DIN       | 除法         | EXP   | 计算指数值     |
| MOD       | 取余         | SIN   | 计算正弦值     |
| NEG       | 求二进制补码 | COS   | 计算余弦值     |
| INC       | 递增         | TAN   | 计算正切值     |
| DEC       | 递减         | ASIN  | 计算反正弦值   |
| ABS       | 计算的绝对值 | ACOS  | 计算反余弦值   |
| MIN       | 获取最小值   | ATAN  | 计算反正切值   |
| MAX       | 获取最大值   | FRAC  | 返回小数       |
| EXPT      | 取幂         |       |                |

### 6 移动操作

<略>学习中……

### 7 转换操作

<略>学习中……

### 8 程序控制指令

<略>学习中……

### 9 字逻辑运算操作

<略>学习中……

### 10 移位和循环

## 编程操作及注意事项

### 西门子plc编程规范

#### 启动标准流程：

​	启动流程：

​	编译项目--> 下载项目 --> stop plc--> run plc -->打开监控模式（小眼睛）

​	停止流程：

​	stop plc--> 关闭监控模式 --> 设置成离线模式 

​	中间需要修改代码：

​	上述停止流程后在修改，修改好之后重新执行一次启动流程

wincc模拟流程：

昆仑通态注意事项：

​	连接机制勾选put/get

### 设置HZ频率

![](HZ频率设置.png)

地址不能使用默认设置，会影响其他地址的使用

**使用方式**

![](HZ梯形图使用方式.png)

### 双线圈问题

![](双线圈问题.png)

双线圈最新的结果就会覆盖掉前面的结果
双线圈问题一旦出现，决定该线圈状态的是程序中最后一个线圈的逻辑运算结果。

解决方案：

1.把线圈变成一个，将前面的触点并起来之后再与线圈连接

![](双线圈问题解决方案1.png)

2.换掉线圈，使用置位指令，因为置位指令不同于线圈，其前面不导通时也不会对线圈进行任何操作，所以无需担心后面线圈的逻辑运算结果会覆盖前面的

![](双线圈问题解决方式2.png)



### 下位组件错误

​	解决方式：（一般只要不影响项目运行就不管，有可能是项目缓存没有刷新好，等等就好了）

​		1.在软件中右击plc项目软件全部重构

​		2.直接编译（一般只要不影响项目运行）

​		3.下位组件重新分配名称

## 参考文献

工业互联网：https://blog.csdn.net/weixin_45586124/article/details/136580828

[驽马同学](https://blog.csdn.net/qq_37424623)：https://blog.csdn.net/qq_37424623/article/details/116642032