---
title: 西门子PLC基础
typora-root-url: 西门子PLC基础
keywords: '西门子,PLC'
tags: 西门子PLC
categories: 西门子PLC
description: 西门子PLC基础 TIA博途S7-1200学习笔记
abbrlink: a5a5d18
date: 2024-08-17 12:42:44
photos:
---

西门子PLC基础 TIA博途S7-1200学习笔记

<!--more-->

------

PLC(Programmable Logic Controller)控制系统，即可编程逻辑控制器，是专为工业生产和控制而设计的一种**数字运算**操作的电子装置，并采用可编程的存储器，用于其内部存储程序，执行**逻辑运算，顺序控制，定时，计数与数据处理**等面向用户的指令，并通过**数字或模拟式输入/输出端口**控制各种类型的机电设备或生产过程，是工业控制的核心部分。

## 接线

[cpu接线图]: https://www.ad.siemens.com.cn/productportal/prods/s7-1200_plc_easy_plus/06-IO/01-CPU/01-wiring.html

输入I点接负，输出Q点接正

![](cpu接线.png)

其中，24V DC传感器电源输出要获得更好的抗噪声效果，即使未使用传感器电源也可将“M”连接到机壳接地。对于漏型（低电平）输入，将“_”连接到“M”(如图所示)对于源型（高电平）输入，将“+”连接到“M'

一般情况下L接正，M接负 ， 1M公共端接负（也可以接正）空格不接线

[串口接线]: https://www.ad.siemens.com.cn/productportal/prods/s7-1200_plc_easy_plus/11-Comm/03-Serial/01-PTP/02-Wire.htm



## PLC控制系统

主要分为：

​	上位机 : 监控设备状态控制设备 例PC或触摸屏
​	控制系统 ：对现场设备进行控制，记录现场运行数据，将现场设备运行状态传送至上位机
​	执行装置 ：电动机为执行装置，负责执行PLC发出的指令，完成生产

## 组态：

“组态(Configure)”的含义是“配置”、“设定”、“设置”等意思，是指用户通过类似“搭积木”的简单方式来完成自己所需要的软件功能，而不需要编写计算机程序，也就是所谓的“组态”。它有时候也称为“二次开发”，组态软件就称为“二次开发平台”。

## 伺服：

伺服系统：是使物体的位置、方位、状态等输出，能够跟随输入量或给定值的任意变化而变化的自动控制系统。

## 基本结构与工作原理

### 简介：

SIMATIC S7-1200是西门子公司的一款紧凑型、模块化的PLC，可完成简单与高级逻辑控制、触摸屏(HMI)网络通信等任务。对于需要网络通信功能和单屏或多屏HMI的自动化系统，易于设计和实施。具有支持小型运动控制系统、过程控制系统的高级应用功能。
1200系列PLC的CPU 将微处理器、集成电源、输入和输出电路、内置PROFINET、高速运动控制 I/O以及板载模拟量输入组合到一个设计紧凑的外壳中来形成功能强大的控制器。

### CPU：

S7-1200 系列CPU有五种不同型号的模块，分别为CPU1211C、CPU1212C、CPU 1214C、CPU1215C和CPU1217C。每一种模块都可以进行扩展，以满足用户系统需要。用户可以在任何型号的CPU 前方加入一个信号板，用来扩展数字量或模拟量 I/O，同时不影响控制器的实际大小，也可将信号模块连接至 CPU 的右侧以进一步扩展数字量或模拟量 I/0 的容量。

![](CPU.png)

#### 组成：

#### cpu模块

1 电源接口;
2 存储卡插槽(上保护盖下面):
3 可拆卸用户接线端子;
4 板载I/0状态指示LED;
5 PROFINET连接端口(CPU的底部)。

该CPU提供一个PROFINET端口用于与其他模块进行PROFINET网络通信。还可以使用附加模块通过PROFIBUS、RS485、RS232、GPRS、IEC等协议进行网络通信。电源接口用于给CPU提供24V直流电，存储卡可以作为CPU的预装载存储区，用户项目文件仅存储在卡中，CPU中没有项目文件离开存储卡将无法运行;忘记密码时，清除CPU内部项目文件和密码;存储卡还可以用于更新S7-1200CPU的固件版本(只限24M卡)。接线端子用于PLC与外部设备进行数字或模拟通讯:PROFINET连接端口用于PLC与外部设备以及编程计算机进行总线通讯。

#### 信号模块：

信号模块又称为SM模块(Signal Module)包括数字量输入模块(DI)、输出模块(DO)和模拟量输入模块(AI)、输出模块(AO)

输入模块用于采集和接收输入信号，数字量输入模块(DI)用于接收开关、按钮、限位开关、光电开关、继电器等过来的数字量输入信号;模拟量输入模块(AI)用于接收电位器，温度传感器，测速发电机，压力传感器等提供连续变化的模拟量信号。

输出模块用于控制外部设备。数字量输出模块(DO)用于控制接触器、继电器指示灯、电磁阀等数字量控制外设:模拟量输出模块(AO)可用于控制变频器、压力阀等模拟量控制的外设。

#### 通信模块：

![](通信模块.png)

通信模块（CB）安装在CPU模块的左边，最多可以添加三块通信模块，可以使用点对点通信模块、RPOFIBUS模块、AS-i接口模块和IO-Link模块等



#### PLC的工作过程

##### CPU的工作模式

CPU有3种工作模式:RUN(运行)、STOP(停机)和STARTUP(启动)面板上的状态LED用来显示当前的控制模式，可以用编程软件改变CPU的工作模式,STOP模式下，CPU只处理通信请求和进行自诊断，不执行用户程序，不更新过程映像。上电后CPU进入STARTUP(启动)模式，进行上电诊断和系统初始化，如果检查到错误，将禁止CPU进入RUN模式，保持在STOP模式，指示灯会变成红色，且闪。

##### 工作模式的切换

1200系列CPU模块上没有切换工作模式的选择开关，只能用STEP7变成软件在线工具中的CPU操作面板。或者工具栏上的![](启动1.png)和 ![](停止2.png) 按钮，来切换RUN或者STOP工作模式，也可在用户程序中用STP指令让CPU进入STOP模式。

##### 冷启动与暖启动

下载了用户程序的程序块和硬件组态后，下一次切换到RUN模式时，CPU会执行冷启动。冷启动时复位输入，初始化输出，复位存储器，即清除工作存储器、非保持性存储区和保持性存储区的数据，并将装载存储器的内容复制到工作存储器。存储器复位不会清除诊断缓冲区，也不会清除永久保存的IP地址

冷启动之后，在下一次下载程序之前的STOP到RUN模式的切换均为暖启动。暖启动时，所有费保持性的系统数据和用户数据被初始化，不会清除保持性存储区的数据。

## plc工作原理：

**硬件自检**

CPU
通信模块
内存
扩展模块和接口
I/O模块
电源模块

如果有问题ERR报警灯就会亮

PLC **重启**方式（重启可以解决大部分的问题）

方式1:钥匙或拨码开关

用于将PLC切换到STOP状态，然后再切换到RUN状态，从而实现重启。

方式2:手动复位按钮

一些PLC上会有手动复位按钮按下该按钮可以将PLC重置为初始状态，实现重启。

方式3:编程软件在线控制

通过PLC的编程软件(如西门子的STEP7、Codesys等)连接到PLC，然后在软件中进行在线操作，将PLC切换到STOP状态，再切换到RUN状态，实现重启。

**自检没有问题就会进行初始化**

数据区清零与恢复
输出量置位或复位

因为大多数PLC没有断电保持的功能（断电保持是指在PLC断电后其内部某些关键数据、程序或状态信息仍然能够保持并在电源恢复后能够继续使用的功能。）

**之后进行扫描**

```markdown
输入扫描-->扫描程序，执行程序-->输出刷新-->输入扫描
```

先进行输入的扫描，扫描的过程中输入发生变化，还是会按照老的输入状态执行，之后以从上至下从左至右的顺序扫描程序，实时刷新plc中的寄存器（计数器寄存器，定时寄存器，辅助继电器，内部继电器），程序扫描完之后，对输出的程序进行统一刷新输出

**运行过程中线程自检**

比如，

1.运行看门狗 （Watch Dog Timer）
即看门狗定时器时钟，如果在指定时间内没有喂狗(清零)操作，则重启扫描程序，避免死机。

2.通讯模块前置到输入采样的前面
PLC的通讯模块能够实现与多种设备的数据传输，包括传感器、执行器、其他PLC以及上位计算机(如工控机)等。通过通讯功能，PLC能够实时获取这些设备的数据，并将处理后的数据发送出去，从而实现整个工业自动化系统的数据共享和协同工作。

**PLC数据存储方式**

数据在存储器中是以字节方式存储的

程序在内存中相当于0-255的数字（2的8次方减1）

**计算机如何理解这些数字？**

计算机的每条指令对应一个具体的行动，指令分为操作码和操作数。操作码理解为要执行的动作，操作数可以理解为对应动作的属性，表示怎么干，现在只需要给每一条指令分配一串唯一的数字（例如 20 80 00 00 这样的机器语言）这样计算机就可以理解了

cpu中有程序计数器，可以理解为书签，cpu通过书签去判断程序运行到了哪一行

cpu有三个动作：1.读取指令2.翻译代码3.执行指令

cpu执行完一条指令的时候，程序计数器就会加1，当遇到跳转指令的时候就会修改程序计数器的数值，跳转到对应指令继续执行

## 编程方式：

### 梯形图

![](梯形自锁程序.png)

逻辑用梯形图

### 功能块图

功能块图(FBD)使用类似于数字电路的图形逻辑符号来表示控制逻辑，几乎没人用

用鼠标右键点击'MAIN(OB1)”，找到“切换编程语言”，选择“FBD”

### SCL语言

![](SCL语言案例.png)

数据处理用SCL

SCL(Structured Control Language，结构化控制语言)是一种基于PASCAL的高级编程语言。SCL除了包含PLC的典型元素(例如输入、输出、定时器等)外，还包含高级编程语言中的表达式、运算符和赋值运算。SCL提供了简便的指令进行程序控制如创建程序分支、循环或跳转。SCL主要适用于以下领域:数据处理、过程优化、数学运算和统计任务等。

## 系统存储区：

### PLC选择的物理存储器

1)只读存储器(ROM)。只读存储器只能读出，不能写入，**是非易失性存储器电源中断也不会造成数据的丢失，一般用来存放PLC的操作系统**。

2)随机存储器(RAM)。CPU可以从存储器读出数据或者向存储器写入数据，**是易失性存储器，电源中断后，存储器的数据丢失**:

3)快闪存储器(FLASH EPROM)和电擦除存储器(EEPROM)**是非易失性存储器，用来存放用户程序和断电时需要保护的重要数据**。

### 装载存储器

装载存储器用于非易失性的存储用户程序、数据和组态信息，能够在断电后继续保持，该存储区位于存储卡(如果有)或者CPU中。项目被下载到CPU后，首先存储在装在存储区中。

### 工作存储器

工作存储器是易失性存储器，用于在执行用户程序时存储用户项目的某些内容。CPU会将一些项目内容从装载存储区复制到工作存储区中，该存储区在断电后丢失，在回复供电时由CPU恢复。

### 断电保持存储器

保持存储器用于在断电时存储所选用户存储单元的值。断电发生时，CPU留出了足够的缓冲时间来保存几个有限的指定单元的值，这些被保持的值会在下次供电时恢复。暖启动后，断电保持存储器中的数据保持不变，冷启动时断电保持存储器的值会被清除。

存储卡
可选的SIMATIC存储卡可用作存储用户程序的替代存储器，或用于传送程序，如果使用存储卡，CPU将运行存储卡中的程序，而不是自身存储器中的程序。(CPU仅支持预先已格式化的存储卡。存储卡保护开关要离开“LOCK”位置，关掉写保护功能。存储卡可将项目复制到多个CPU中，传送卡将存储的项目从卡中复制到CPU的存储器后必须取出存储卡。存储卡作为程序卡使用时，可以替代CPU存储器，所有CPU功能都由该程序卡进行控制，插入程序卡会擦出CPU内部装载存储器的所有内容(包括用户程序和任何强制I/0)，然后**CPU会执行程序卡中的用户程序，程序卡必须保留在CPU中，如果取出，CPU必须切换到STOP模式**。

## 基本数据类型：

数据类型组中定义有数据的属性，例如：内容及有效存储区的表示。

在用户程序中，可使用预定义的数据类型，并将这些数据类型添加到用户自定义数据类型中。此时，可使用以下类别：

基本数据类型（二进制数、整数、浮点数、定时器、DATE、TOD、LTOD、CHAR、WCHAR）

复杂数据类型（DT、LDT、DTL、STRING、WSTRING、ARRAY、STRUCT）

用户自定义数据类型（PLC 数据类型 (UDT)）

指针

参数类型

系统数据类型

硬件数据类型
————————————————

| 数据符号      | 数据名称                                                     | 取值                                                         | 数值类型     | 应用范围                                                     | 输入示例                                      |
| ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------ | ------------------------------------------------------------ | --------------------------------------------- |
| BOOL          | 布尔，是表示1位的值                                          | 0或1                                                         | 二进制数     | 逻辑计算                                                     | TRUE，FALSE，0，1                             |
| BYTE          | 字节，是位字符串，占有8位                                    | 16#00—16#FF                                                  | 二进制数     | 逻辑计算                                                     | 16#12，16#AB                                  |
| WORD          | 字，是位字符串，占有16位                                     | 16#0—16#FFFF                                                 | 二进制数     | 逻辑计算                                                     | 16#ABCD，16#0001                              |
| DWORD         | 双字，是位字符串占有32位                                     | 16#0—16#FFFF FFFF                                            | 二进制数     | 逻辑计算                                                     | 16#02468ACE                                   |
| LWORD         | LWORD是一个64位的无符号整数，它可以存储64位的数据。          | ~                                                            | 二进制数     | 逻辑计算，如果你需要存储大量的位数据，使用LWORD将会很方便。  |                                               |
| Char          | 字符，占有8位                                                | ASCII 字符                                                   | 字符         |                                                              | 'A','@','t'                                   |
| WCHAR         | 宽字符，占有16位                                             | ASCII 字符                                                   | 字符         | WCHAR 数据类型将扩展字符集中的单个字符保存为 UFT-16 编码形式。 | WCHAR#‘A’                                     |
| STRING        |                                                              | ASCII 字符串，包括特殊字符                                   | 字符串       |                                                              | “name”                                        |
| SINT          | 有符号短整型，占有8位                                        | -128—127                                                     | 整型         | 数学计算                                                     | 123，-123                                     |
| USINT         | 无符号短整型，占有8位                                        | 0—255                                                        | 整型         | 数学计算                                                     | 123                                           |
| INT           | 有符号整型，占16位                                           | -32768—32767                                                 | 整型         | 数学计算                                                     | 123，-123                                     |
| UINT          | 无符号整型，占16位                                           | 0—65535                                                      | 整型         | 数学计算                                                     | 123                                           |
| DINT          | 有符号双整型，占32位                                         | -2,147,483,648—2,147,483,647                                 | 整型         | 数学计算                                                     | 123，-123                                     |
| UDINT         | 无符号双整型，占32位                                         | 0—4,294,967,295                                              | 整型         | 数学计算                                                     | 123                                           |
| LINT          | 有符号长整型，占有8位                                        | ~                                                            | 整型         | 数学计算                                                     | 123，-123                                     |
| ULINT         | 无符号长整型，占有8位                                        | ~                                                            | 整型         | 数学计算                                                     | 123                                           |
| Real          | 单精度浮点数，最多可以指定 6 位有效数字来保持精度，占有32 位 | 实数：+/-1.18x10∧－38到+/-3.40x10 ∧38                        | 浮点数       |                                                              | 123.456、-3.4、-1.2E+12、<br/>3.4E-3          |
| LReal         | 双精度浮点数，最多可以指定 15 位有效数字来保持精度，占有64 位 | 长实数：+1-2.23x10∧ -308 到 +/-1.79 x10 ∧308                 | 浮点数       |                                                              | 12345.123456789，-1.2E+40                     |
| Time          | 32                                                           | T#-24d 20h 31m 23s 648ms toT#24d 20h_31m_23s_647ms<br/>存储形式:-2,147,483,648 ms to+2.147.483.647 ms | 时间         |                                                              | T#5m_30s<br />5#-2d<br />T#1d_2h_15m_30x_45ms |
| String        | 变量                                                         | 0 到 254 字节字符 字符串                                     | 字符串       |                                                              | 'ABC'                                         |
| DTL∧1         | 12个字节                                                     | 最小值:DTL#1970-01-01-00:00:00.0最大值:DTL#2554-12-31-23:59:59.999 999999 | 日期         |                                                              | DTL#2008-12-16-20:30:20.250                   |
| Array（数组） |                                                              |                                                              | 复杂数据类型 |                                                              |                                               |

**word数据类型可以写成16个%X，%X1-%X16**

因为word是16位，%X表示一个二进制位



## 寄存器分类：

计算机内部都是以“0”、“1”二进制形式存储的，最小的存储单元位通常位一个字节（8个比特位：8bit），1bit位就是**存储元**（晶体管构成门电路，门电路构成锁存器或触发器，锁存器或触发器构成存储元）

一个字节存储单元

而根据CPU读写数据速度的不同，存储区域又可以划分为不同的存储区，相当于**居民小区**里有很多幢**居民楼**（进一步理解，可以将居民楼里的房间理解为**存储元**）,距离小区门口近的居民楼，进出小区自然是又快又方便。同理，距离CPU路程越近的存储区，其数据的访问速度也会越快，这块存储区我们称为**寄存器**，也是价格最贵的一块存储区。

PLC（可编程控制器）也是一个小型的计算机，它的CPU内部有用于PLC程序、数据和组态信息保存的**装载存储器**，有用于程序运行的工作存储器（相当于PC的运行内存RAM），有用于非易失性地存储限量的工作存储器值的保持性存储器。而用于用户程序在执行期间数据存储的地方称为数据存储区，这片存储区也是集成在CPU内部的，包括以下几大类：

| 存储区                      | 说明                                                         | 强制                     | 保持性 |
| --------------------------- | ------------------------------------------------------------ | ------------------------ | ------ |
| I 存储区<br/>(过程映像输入) | 在扫描周期开始时读取输入端子外围设备的“开”“关”的状态，将状态值写入到存储区 | 立即输入点<br />支持强制 | 无     |
| Q 存储区<br/>(过程映像输出) | PLC程序运算的输出值不会直接作用到输出端子的设备上，而是在扫描周期开始时先复制到Q存储区 | 立即输出点<br />支持强制 | 无     |
| M 存储器                    | 中间数据存储器，比如程序运算的一个中间值可以存到这里         | 无                       | 可选   |
| 临时存储器L                 | 存储块的临时数据，这些数据仅在该块的本地范围内有效           | 无                       | 无     |
| DB数据块                    | 数据存储器，同时也是FB(功能块)的参数存储器                   | 无                       | 可选   |

## 寻址方式:

程序在执行的过程中需要读写数据，而读写数据的第一步就是寻址（址：数据的地址，PLC中所有能访问的数据都有地址，就像每个人都有一个身份证一样），寻址方式分为：按位寻址、按字节寻址，按字寻址和按双字寻址

### 按位寻址

![](按位寻址.png)

按位寻址就是一次访问一个存储元的存储值，上图黑色存储元在Byte2字节Bit2位处，那么对他的寻址（访问）方式就是**M2.2**，“M”表示存储器的标识符，第一个“2”表示字节号，第二个“2”表示位号。

### 按字节寻址

![](按字节寻址.png)

按字节寻址就是一次访问或者读写一个字节大小（8个bit位）的存储区，上图中绿色区域为Byte3，对他的寻址就是**MB3**，“M”表示存储器的标识符，“B”表示为按字（Byte）节寻址，“3”表示字节号。

### 按字寻址

![](按字寻址.png)

按字寻址就是一次访问或者读写2个字节（16个bit位），上图中绿色和蓝色存储区的寻址方式分别位MW1和MW5，“M”表示存储器的标识符，“W”表示为按字（Word）寻址，“1”和“5”表示字节号。

### 按双字寻址

![](按双字寻址.png)

按双字寻址就是一次访问或者读写4个字节（32个bit位）的数据，上图中绿色和蓝色区域的寻址方式分别位MD0和MD4，“M”表示存储器的标识符，“D”表示为按双子（Double Word）寻址，“0”和“4”表示字节号

### 寻址案例：

![](寻址案例.png)

程序运行时，每个扫描周期都会对I和Q存储器寻址，比如，当IO.0寻址的值为“1”，则常开触点闭合，若此时急停按钮时闭合的（急停按钮一般是一对常闭触点），则输出线圈Q0.0闭合，Q存储器0字节0位这个存储元就被写入“1”，这个存储元的“1”值会在下一个扫描周期开始时将PLC的Q0.0这个输出端子接通，KM接触器线圈得电，主电路接通，电机工作。

## 程序块及类别

![](程序块.png)

在PLC的编程中，**程序块**是指一组逻辑控制代码，用于实现系统中特定的控制功能。程序块主要分为四类，包括函数块（FB）、函数（FC）、数据块（DB）和组织块（OB）四种类型。不严谨的说，组织块（OB）可以相当于主程序，函数块（FB）和函数（FC）可以相当于子程序，数据块（DB）可以相当于数据存储区。



关心数据FB

不关心数据FC

全局数据块DB

OB主程序不能被其他系统调用



### 函数块（FB）

![](函数块.png)



描述：函数块是用户编写的包含经常使用的功能的子程序，其含有专用的背景数据块。
由于运行过程中需要调用各种参数，因此产生了背景数据块DB，所以需要用到的数据就存储在了DB中。即使结束调用，数据也不丢失。

函数块（Function Block）是PLC编程中最常用的程序块类型。它类似于面向对象编程中的类，用于封装特定的控制逻辑，并将其作为一个整体进行调用和重复使用。函数块可以由多个输入和输出组成，它们的功能通常与具体的硬件设备相关。例如，一个函数块可以用来控制一个电机，另一个函数块可以用来实现温度控制。函数块通常由多个网络组成，每个网络包含了一个或多个指令，它们共同实现函数块的控制逻辑。一个函数块可以被多个程序或函数调用，这使得程序的编写变得更加高效和简单。

CPU执行FB中的程序，将块的输入输出参数和局部静态变量保存在背景数据块中，以便在后面的扫描周期访问它们。FB的典型应用是执行不能再一个扫描周期完成的操作。在调用FB时，会自动打开对应的背景数据块，数据块中的变量可以供其他代码块使用。

### 函数（FC）

![](函数.png)

函数也是用户编写的包含经常使用的功能的子程序。

函数（Function）与函数块非常相似，但它只包含一个网络，通常用于实现简单的控制逻辑。与函数块不同的是，FC无专用的背景数据块，函数（FC）在运行时产生的临时变量保存在全局数据块DB中，函数没有输入和输出参数，它只是将数据作为参数进行处理，然后返回处理结果，执行结束后，数据将丢失，不具备存储功能。函数通常用于实现一些通用的算法，例如加减乘除、求平方根、三角函数等。

可以在程序的不同位置多次调用同一个FC或FB块，这样可以简化重复执行的任务编程。

### 数据块（DB）

![](数据块.png)

数据块（Data Block）是PLC编程中用于存储和管理数据的程序块类型。数据块可以包含各种数据类型，例如整型、浮点型、字符型等。在程序中，可以通过数据块来读取和写入变量的值。数据块通常用于存储程序的输入、输出、状态等数据，也可以用于存储程序运行过程中的临时变量。数据块可以在程序块之间共享，这使得程序的编写变得更加高效和简单。例如，如果多个函数块需要共享一个变量，可以将这个变量定义为一个数据块，并在函数块中引用它。

数据块分为背景数据块和全局数据块两种。
背景数据块是专门用于保存函数块（FB）中的输入变量，输出变量和静态变量的。其中的数据在编译时自动生成。FB的临时数据不是用背景数据块保存的。
全局数据块是一片存储用户数据的区域，供所有的代码块访问，所有的OB、FB和FC都可以访问，全局数据块也被称为共享数据块.

创建好数据块要看偏移量，需要右击数据块，取消优化的块访问，再编译下项目就可以看到偏移量

### 组织块（OB）

![](组织块.png)

组织块（Organization Block）是PLC编程中用于管理程序运行的程序块类型。组织块可以控制程序的执行顺序、周期、中断等。在程序中，通常需要定义一个或多个组织块来实现程序的运行和控制。组织块是CPU操作系统与用户程序的接口，决定了用户的程序结构。组织块将自动被操作系统调用。
使用中有中断组织块，启动组织块等。
使用时必须有OB1组织块，操作系统每个扫描周期执行一次OB1。

组织块通常由多个网络组成，每个网络包含了一个或多个指令，它们共同实现组织块的控制逻辑。组织块可以被编译成PLC的内部指令，以便在PLC运行时进行执行。在程序中，通常需要将组织块与输入和输出绑定，以便实现程序的运行和控制。

在PLC编程中，组织块可以分为多种类型，例如主程序（Main Program）、子程序（Subroutine）、中断（Interrupt）、异常（Exception）等。每种类型的组织块都有其独特的用途和应用场景，可以根据需要选择适合的类型。

每个组织块必须有唯一的编号，123号之前的一些编号是保留的，其他OB的编号应大于等于123。0B块不能互相调用，也不能被FC和FB块调用，只有启动事件(如周期性中断事件或诊断中断事件)可以启动OB块的执行。OB1是用户程序中的主程序，在每一次循环中，操作系统程序调用一次0B1，因此0B1中的程序时循环执行的。一个PLC程序中允许有多个程序循环，默认的块是OB1，其他的循环程序OB的编号必须大于等于123



### 程序块作用：

函数块和函数用于实现控制逻辑，数据块用于存储和管理数据，组织块用于管理程序的执行顺序、周期、中断等。



程序块的使用可以**使PLC程序的编写变得更加高效和简单**。

通过使用程序块，**可以将复杂的控制逻辑封装为一个整体，实现代码的重复使用和共享**。

程序块也可以**提高程序的可读性和可维护性，降低程序的出错率**。

### 程序块的选择：

在PLC编程中，**需要根据具体的应用场景选择适合的程序块**类型。

​	例如，
​	如果需要实现电机控制，可以选择函数块；
​	如果需要实现通用的算法，可以选择函数；
​	如果需要存储和管理数据，可以选择数据块；
​	如果需要管理程序的执行顺序、周期、中断等，可以选择组织块。

## 指令集

以串联方式连接的触点创建与（AND）逻辑程序段。以并联方式连接的触点创建或（OR）逻辑程序段。 可将触点相互连接并创建用户自己的组合逻辑。如果用户指定的输入位使用存储器标识符I（输入）或Q（输出），则从过程映像寄存器中读取位值。

控制过程中的物理触点信号会连接到PLC上的I端子。CPU扫描已连接的输入信号并持续更新过程映像输入寄存器中的相应状态值。

通过在I偏移量后加入“:P”，可指定立即读取物理输入（例如：“%I3.4:P”）

通过在Q偏移量后加入“:P”，可指定立即写入物理输出。对于立即写入，将位数据值写入过程映像输出寄存器并直接写入物理输出。

### 1 位逻辑运算操作

![](位逻辑指令.png)



1.1 常开触点
**—| |—**

1为OFF，0为ON。

1.2 常闭触点
**—|/|—**

1为ON，0为OFF。

1.3 取反触点
**—|NOT|—**
输入为0，输出为1，输入为1输出为0；

1.4 线圈
**—( )—**
1.5 赋值取反
**—( / )—**
将逻辑运算的结果进行取反，然后将其赋值给这个线圈的操作数。

1.6 复位输出
**—( R )—**
1.7 置位输出
**—( S )—**
1.8 置位位域
**—( SET_BF )—**
1.9 复位位域
**—( RESET_BF )—**
1.10 SR置位/复位触发器

![](SR置位_复位触发器.png)

| 参数 | 说明               |
| ---- | ------------------ |
| S    | 使能置位           |
| RI   | 使能复位，复位优先 |
| SR   | 待使能操作数       |
| Q    | 操作数信号状态     |

SR置位/复位触发器-信号真值表

| S    | RI   | Q    |
| ---- | ---- | ---- |
| 0    | 0    | 保持 |
| 0    | 1    | 复位 |
| 1    | 0    | 置位 |
| 1    | 1    | 复位 |

​		

1.11 RS复位/置位触发器

![](RS复位_置位触发器.png)

| 参数 | 说明               |
| ---- | ------------------ |
| R    | 使能复位           |
| SI   | 使能置位，置位优先 |
| SR   | 待使能操作数       |
| Q    | 操作数信号状态     |

RS复位/置位触发器-信号真值表

| SI   | R    | Q    |
| ---- | ---- | ---- |
| 0    | 0    | 保持 |
| 0    | 1    | 复位 |
| 1    | 0    | 置位 |
| 1    | 1    | 置位 |

1.12 扫描操作数的信号上升沿
**—| P |—**
检测到信号上升沿时，操作数 1 的信号状态将在一个程序周期内保持置位为“1”。在其它任何情况下，操作数的信号状态均为“0”。

| 参数    | 说明                                 |
| ------- | ------------------------------------ |
| 操作数1 | 要扫描的信号                         |
| 操作数2 | 保存上一次查询的信号状态的边沿存储位 |

1.13 扫描操作数的信号下降沿
**—| N |—**
检测到信号下降沿时，操作数 1 的信号状态将在一个程序周期内保持置位为“1”。在其它任何情况下，操作数的信号状态均为“0

| 参数    | 说明                                 |
| ------- | ------------------------------------ |
| 操作数1 | 要扫描的信号                         |
| 操作数2 | 保存上一次查询的信号状态的边沿存储位 |

1.14 在信号上升沿置位操作数
**—( P )—**
当输入查询到上升沿时，操作数置位为1一个程序周期，然后其它时间全为0；

| 参数    | 说明               |
| ------- | ------------------ |
| 操作数1 | 上升沿置位的操作数 |
| 操作数2 | 边沿存储位         |

1.15 在信号下降沿置位操作数
**—( N )—**
当输入查询到下降沿时，操作数置位为1一个程序周期，然后其它时间全为0；

| 参数    | 说明               |
| ------- | ------------------ |
| 操作数1 | 下降沿置位的操作数 |
| 操作数2 | 边沿存储位         |

1.16 P_TRIG扫描 RLO 的信号上升沿

![]( P_TRIG扫描 RLO 的信号上升沿.png)

检测到信号上升沿时，该指令输出 Q 将立即返回程序代码长度的信号状态“1”。在其它任何情况下，该输出返回的信号状态均为“0”。

| 参数   | 说明                                 |
| ------ | ------------------------------------ |
| CLK    | 沿信号输入端，当前RLO                |
| 操作数 | 保存上一次查询的信号状态的边沿存储位 |
| Q      | 边沿检测结果                         |




1.17 N_TRIG扫描 RLO 的信号下降沿

![](N_TRIG扫描 RLO 的信号下降沿.png)

检测到信号下降沿时，该指令输出 Q 将立即返回程序代码长度的信号状态“1”。在其它任何情况下，该输出返回的信号状态均为“0”。

| 参数   | 说明                                 |
| ------ | ------------------------------------ |
| CLK    | 沿信号输入端，当前RLO                |
| 操作数 | 保存上一次查询的信号状态的边沿存储位 |
| Q      | 边沿检测结果                         |

1.18 R_TRIG检查信号上升沿

![](R_TRIG检查信号上升沿.png)

该指令将输入 CLK 的当前值与保存在指定实例中的上次查询（边沿存储位）的状态进行比较。如果该指令检测到输入 CLK 的状态从“0”变成了“1”，就会在输出 Q 中生成一个信号上升沿，输出的值将在一个循环周期内为 TRUE 或“1”。

| 参数 | 说明                         |
| ---- | ---------------------------- |
| EN   | 使能输入                     |
| ENO  | 使能输出                     |
| CLK  | 达到信号，将查询该信号的边沿 |
| Q    | 边沿检测的结果               |

1.19 F_TRIG：检查信号下降沿

![](F_TRIG：检查信号下降沿.png)

该指令将输入 CLK 的当前值与保存在指定实例中的上次查询（边沿存储位）的状态进行比较。如果该指令检测到输入 CLK 的状态从“1”变成了“0”，就会在输出 Q 中生成一个信号下降沿，输出的值将在一个循环周期内为 TRUE 或“1”。

| 参数 | 说明                         |
| ---- | ---------------------------- |
| EN   | 使能输入                     |
| ENO  | 使能输出                     |
| CLK  | 达到信号，将查询该信号的边沿 |
| Q    | 边沿检测的结果               |

1.20 四种沿信号的区别
1.20.1

![](1.20.1.png)

在P触点上面的I0.0的上升沿，该触点接通一个扫描周期。因此P触点用于检测触点上面的地址的上升沿，并且直接输出上升沿脉冲。其他3种指令都是用来检测逻辑运算结果RLO（即流入指令输入端的能流）的上升沿。

1.20.2

![](1.20.2.png)

在流过P线圈的能流的上升沿，线圈上面的地址Q0.1在一个扫描周期为1状态。因此P线圈用于检测能流的上升沿，并用线圈上面M2.2的触点来输出上升沿脉冲。其他3种指令都是直接输出检测结果。

1.20.3&4

![](1.20.3&4.png)

R_TRIG指令与P_TRIG指令都是用于检测流入它们的CLK端的能流的上升沿，并用Q端直接输出检测结果。其区别在于R_TRIG是函数块，用它的背景数据块DB3保存上一次扫描循环CLK端信号的状态，
而P_TRIG指令用边沿存储位M10.3来保存它。P 触点和P线圈分别用边沿存储位M10.0和M10.1来保存它们的输入信号的状态。

| 对比项目   | P触点    | P线圈    | P_TRIG   | R_TRIG     |
| ---------- | -------- | -------- | -------- | ---------- |
| 沿信号来源 | 靠自己   | 靠别人   | 靠别人   | 靠别人     |
| 输出脉冲   | 给别人   | 给自己   | 给别人   | 给别人     |
| 边沿存储   | 自己的位 | 自己的位 | 自己的位 | 背景数据块 |

### 2 定时器指令

IEC：国际电工委员会缩写，IEC定时器表示国际标准定时器。

2.1 TP 脉冲定时器

![](TP_脉冲定时器.png)

当 IN 端收到一个上升沿信号，Q开始输出能流并开始计时，当计时时间达到PT设定时间后，Q不再有能流输出，知道下有一个上升沿信号输入到IN端口。

| 参数 | 说明         |
| ---- | ------------ |
| IN   | 启动输入     |
| PT   | 脉冲持续时间 |
| Q    | 脉冲输出     |
| ET   | 当前时间值   |


2.2 TON 接通延时定时器

![](TON_接通延时定时器.png)

【延时接通，瞬时关断】当IN有能流输入时，且保持一直有，则TON 开始计时，当计时时间达到PT设定时间后，Q输出能流，且只要IN有能流输入，Q便一直有能流输出。

| 参数 | 说明                   |
| ---- | ---------------------- |
| IN   | 启动输入               |
| PT   | 接通延时持续时间       |
| Q    | 超过时间PT后置位的输出 |
| ET   | 当前时间值             |

2.3 TOF 关断延时定时器

![](TOF_关断延时定时器.png)

【瞬时接通，延时关断】当IN有能流输入时，Q输出能流，且只要IN有能流输入，Q便一直有能流输出；当IN从接通改为断开后，则TON 开始计时，此时Q仍有能流输出，当计时时间达到PT设定时间后，Q被复位。

| 参数 | 说明                   |
| ---- | ---------------------- |
| IN   | 启动输入               |
| PT   | 关断延时的持续时间     |
| Q    | 超过时间PT后复位的输出 |
| ET   | 当前时间值             |

2.5 TONR时间累加器定时器

![](TONR_时间累加器定时器.png)

描述： 当IN端接通时，TNOR开始计时，当IN断开时，TNOR停止计时，但当前计时时间不清零，下次IN再接通时计时时间累加，当累加计时时间达到PT设定值后，Q输出能流，此时无论IN 是否接通都不在影响Q输出能流。
当R收到一个上升沿信号时，TONR累计时间清零，Q被复位。

| 参数 | 说明                     |
| ---- | ------------------------ |
| IN   | 启动输入                 |
| R    | 复位输入                 |
| PT   | 时间记录最长持续时间     |
| Q    | 超过时间PT后要置位的输出 |
| ET   | 累计时间值               |

### 3 计数器指令

3.1 CTU 加计数器

![](CTU_加计数器.png)

描述： CU端每收到一个上升沿信号，CTU便做加一计数，当计数值累加到PV设定值后，Q有能力输出；当R端接收到一个上升沿信号后，Q输出复位，CTU计数清零。

| 参数 | 说明           |
| ---- | -------------- |
| CU   | 计数输入       |
| R    | 复位输入       |
| PV   | 置位输出Q的值  |
| Q    | 计数器状态     |
| CV   | 当前计数器的值 |


3.2 CTD 减计数器

![](CTD_减计数器.png)

描述： 程序刚启动时，当CD和LD都没有产生上升沿信号时，Q有能流输出；当LD收到一个上升沿信号，便将PV设定值装载到CTD计数器中，并且复位Q；每当CD收到一个上升沿信号时，CTD自减一，当减到0时，置位Q输出能流。

| 参数 | 说明           |
| ---- | -------------- |
| CD   | 计数输入       |
| LD   | 转载输入       |
| PV   | 装载的计数值   |
| Q    | 计数器状态     |
| CV   | 当前计数器的值 |

3.3 CTUD 加减计数器

![](CTUD_加减计数器.png)

| 参数 | 说明           |
| ---- | -------------- |
| CU   | 加计数输入     |
| CD   | 减计数输入     |
| R    | 复位输入       |
| LD   | 转载输入       |
| PV   | 装载的计数值   |
| QU   | 加计数器状态   |
| QD   | 减计数器状态   |
| CV   | 当前计数器的值 |

描述： cu让计数器自加一，CD让计数器自减一，R给计数器计数值清零，LD将PV的设定值装载到计数器；
计数器值对应的输出状态

| 数值范围 | QU   | QD   |
| -------- | ---- | ---- |
| (+∞,0]   | 0    | 1    |
| (0,PV)   | 0    | 0    |
| [PV,+∞)  | 1    | 0    |

### 4 比较指令

| 指令           | 描述         |
| -------------- | ------------ |
| CMP==          | 等于         |
| CMP<>          | 不等于       |
| CMP>=          | 大于等于     |
| CMP<=          | 小于等于     |
| CMP>           | 大于         |
| CMP<           | 小于         |
| IN_Range       | 值在范围内   |
| OUT_Range      | 值不在范围内 |
| —\| OK \|—     | 检查有效性   |
| —\| NOT OK \|— | 检查无效性   |


检查有效性指令和检查无效性指令只针对浮点数数据类型进行查验。

![](比较指令1.png)

![](比较指令2.png)

### 5 数学函数

| 指令      | 描述         | 指令  | 描述           |
| --------- | ------------ | ----- | -------------- |
| CALCULATE | 计算函数     | LIMIT | 设置限值       |
| ADD       | 加           | SQR   | 计算平方       |
| SUB       | 减           | SQRT  | 计算平方根     |
| MUL       | 乘           | LN    | 计算自然数对数 |
| DIN       | 除法         | EXP   | 计算指数值     |
| MOD       | 取余         | SIN   | 计算正弦值     |
| NEG       | 求二进制补码 | COS   | 计算余弦值     |
| INC       | 递增         | TAN   | 计算正切值     |
| DEC       | 递减         | ASIN  | 计算反正弦值   |
| ABS       | 计算的绝对值 | ACOS  | 计算反余弦值   |
| MIN       | 获取最小值   | ATAN  | 计算反正切值   |
| MAX       | 获取最大值   | FRAC  | 返回小数       |
| EXPT      | 取幂         |       |                |

### 6 移动操作

<略>学习中……

### 7 转换操作

<略>学习中……

### 8 程序控制指令

<略>学习中……

### 9 字逻辑运算操作

<略>学习中……

### 10 移位和循环

<略>学习中……

## 编程操作及注意事项

### 西门子PLC编程规范

#### 启动标准流程：

​	启动流程：

​	编译项目--> 下载项目 --> stop plc--> run plc -->打开监控模式（小眼睛）

​	停止流程：

​	stop plc--> 关闭监控模式 --> 设置成离线模式 

​	中间需要修改代码：

​	上述停止流程后在修改，修改好之后重新执行一次启动流程

wincc模拟流程：

昆仑通态注意事项：

​	连接机制勾选put/get

### 设置HZ频率

![](HZ频率设置.png)

地址不能使用默认设置，会影响其他地址的使用

**使用方式**

![](HZ梯形图使用方式.png)

### 双线圈问题

![](双线圈问题.png)

双线圈最新的结果就会覆盖掉前面的结果
双线圈问题一旦出现，决定该线圈状态的是程序中最后一个线圈的逻辑运算结果。

解决方案：

1.把线圈变成一个，将前面的触点并起来之后再与线圈连接

![](双线圈问题解决方案1.png)

2.换掉线圈，使用置位指令，因为置位指令不同于线圈，其前面不导通时也不会对线圈进行任何操作，所以无需担心后面线圈的逻辑运算结果会覆盖前面的

![](双线圈问题解决方式2.png)



### 下位组件错误

​	解决方式：（一般只要不影响项目运行就不管，有可能是项目缓存没有刷新好，等等就好了）

​		1.在软件中右击plc项目软件全部重构

​		2.直接编译（一般只要不影响项目运行）

​		3.下位组件重新分配名称

## PLC项目整合方式

### PLC总控

使用PLC15系列做PLC总控

负责把其他plc的程序存到一起运行

### 网关

网关主要做数据的收集处理

## 通讯

### PROFINET和PROFIbus之间的关系

PROFINET=PROFIbus+etherNET，把Profibus的主从结构移植到以太网上，所以profinet会有Controller和Device，他们的关系可以简单的对应于profibus的Master和Slave，当然，是有区别的，但这样对应可以有助于理解。另外由于profinet是基于以太网的，所以可以有以太网的星型、树形、总线型等拓扑结构，而profibus只有总线型。所以profinet就是把profibus的主从结构和ethernet的拓扑结构相结合的产物，其他像等时性等西门子鼓吹的特性其实以太网也有，只不过profinet由于有Controller这样的控制单元可以提高等时性的精度而已。

PROFINET 是一种新的以太网通讯系统。PROFINET 系统集成了基于 Profibus 的系统，提供了对现有系统投资的保护。它也可以集成其它现场总线系统。

PROFINET同样是西门子SIMATIC NET中的一个协议，具体说是众多协议的集合，其中包括PROFINET IO RT, CBA RT, IO IRT等等的实时协议。所以说PROFINET和工业以太网不能比，只能说PROFINET是工业以太网上运行的实时协议而以。不过现在常常称有些网络是PROFINET网络，那是因为这个网络上应用了PROFINET协议而已。

### PROFINET和Modbus的区别

PROFINET是基于工业以太网的总线协议，通过网线进行数据传输，Modbus是基于串口485/232/422的现场总线协议，多见于仪表等设备。实现Modbus和ProfiNet的转换可以使用上海泗博自动化的TS-180，TS-180主要实现M串口和ProfiNet的转换，串口端支持自定义协议，可以连接多个Modbus从站设备



### 串口通讯的工作原理是什么?浅析串口协议的三层结构	

#### **一个数据位占多长时间?**

使用异步传输，约定波特率

比如每秒展示一个位，1位/秒，发送方每1秒钟展示一位数据，接收方每1秒钟接收一位数据，这种表示通讯速度的物理量叫作**波特率**，波特率默认为9600位/秒

一盏灯的时候双方目标速度相同但是实际操作起来速度很难一致，这样的通讯叫作**异步通讯**

引入时钟信号，我们在发送一位数据的时候时钟信号灯就亮一次，引入时钟信号的两盏灯的时候，数据接收方不需要关心速度只需要根据发送方的速度来接收数据，这样的传输叫作**同步传输**

#### **怎样确定数据从哪开始?**

通过开始位判断发送何时开始

发送数据之前发送一个特殊的信号表示传输的开始，当不发送数据信号时就让灯保持点亮，发送数据之前线让灯熄灭一秒2-9秒发送表示字符的八位数据

#### **收发节奏不同步怎么办？**

限制数据长度通过结束位分割

发送多个数据的时候首发双方的实际节奏略有不同，两个设备之间通讯，设备的时钟振荡器也不会完全相同，数据量少的时候不影响，数据量大的时候就会出现累积误差（会把下一位的数据当成当前位数据去读取，数据乱码），解决方式是添加开始位和结束位，每读取一个字符数据就停一下，让灯固定亮一秒作为结束位，接收方在看到下一个开始位时由新的开始位重新确定每一位的数据采集时间，就能避免累计误差

#### **接收数据对错如何检验?**

通过校验位 进行奇/偶校验

既可以收又可以发的通信叫作双工通信
灯光传输可以同时收发叫作全双工通信
鼓声传输就像对讲机一样同一时间只能由一方说话叫作半双工通信

只能由一方发送另一方或者几方接收叫作单工通信

#### 三层结构

三层结构对应协议

![img](三层结构对应的协议.png)

##### 物理层

将0和1的信号与声、光、电压一类的物理信号相互转换

工控常见的物理层协议

![img](物理层.png)

##### 数据链路层

将文字数据转换成0101的比特流或者将比特流转换成文字数据

数据链路层UART协议的工作原理（异步通讯）

![img](数据链路层.png)

使用UART通讯时需要约定好波特率、数据长度、校验方式、结束位长度，默认是

![img](默认uart协议数据.png)

数据链路层协议还有PROFIBUS、CC-Link、SPI和IIC，其中SPI和IIC这两个协议是同步通讯的需要时钟线，嵌入式领域常用，工控领域几乎没有

##### 应用层

分为主站和从站，从站不能发送信息，只需要执行主站的任务

从站地址报文格式

![img](从站地址的报文.png)

一个主站给多个从站发送信息，看报文中具体的从站地址，地址不相同的从站会忽略掉指令

主站和从站之间的通讯要轮询执行、

**应用层协议**

Modbus、PROFIBUS、CC-Link

##### 三层机构之间的关系

**物理层**只定义1和0和物理量之间的对应关系

**数据链路层**不关心底层0和1是怎么实现的只负责二进制数据流和字节数据相互转换

**应用层**不关心数据是怎么获取的，只定义数据与业务逻辑的对应关系

没有应用层，只使用物理层和数据链路层通讯只能起到传声筒作用，通讯双方必须编写业务逻辑，使用Modbus、PROFIBUS，主站就可以随意查询和修改从站内部变量，或者周期性同步从站数据，把从站视为主站一部分

### 开放式用户通信

```markdown
		组态模块：

				通信-->开放式用户通信（Socket通信）

						TSend_C：建立连接发送数据

								触发条件：

										REQ："Clock_5Hz"
										CONNECT：使用模块右上角小蓝盒进行组态
										DATA：plc发送给机器人指令数据

						TRCV_C：建立连接接收数据

								触发条件：

										EN_R："AlwaysTRUE"
										CONNECT：使用模块右上角小蓝盒进行组态
										DATA：机器人响应并返回给plc的数据

		注意：机器人与plc的数据是不兼容的需要进行数据的转换，输入/输出进行单独转换

		案例：机器人与PLC通讯交互
```



### MODBUS TCP

```markdown
		组态模块：

				通信-->其他-->Modbus Tcp

				MB_CLIENT：通过PROFINET进行通信，作为客户端

						触发条件：

								REQ："AlwaysTRUE"
								DISCONNECT："AlwaysFALSE"
								MB_MODE：Modbus 的请求模式（读取、写入或诊断）  0：读    1，2：写
								MB_DATA_ADDR：这里对应需要匹配的仓位的起始地址
								MB_DATA_LEN：代表仓位的数量
								MB_DATA_PTR：P#DB4.DBX14.0 BOOL 8 表示哪个db块数据类型和所占存储区容量
								CONNECT ：连接通信协议TCON_IP_v4，一般建立单独db块，数据类型选择
										InterfaceId：默认64
										ID：不重复就可以
										ActiveEstablished：
												主动连接：true，将当前PLC作为TCP通信的客户端
												被动连接：false，将当前PLC作为TCP通信的服务器
										RemoteAddress：表示要连接的设备ip地址
										RemotePort：要连接的设备的端口

				MB_SERVER：通过PROFINET进行通信，作为服务端

		案例：立体仓库
```



### RFID

```markdown
通过硬件通讯：

		组态硬件：

				使用串口硬件 RF_120C RS422进行通信

				对芯片进行读写时Ident设备/系统要选择  通过FB/光学阅读器获取参数

		组态软件：

				Ident工艺对象

						普通阅读器

		组态模块：

				选件包--> SIMATIC Ident（全双工：使用串口RF_120C 422）

						复位块：
								Reset_RF300：错误复位  （根据模块的实际型号选最近的）

										触发条件：

												EXECUTE：使用常开开关+FirstScan进行控制（FirstScan程序启动先执行一次进行复位）
												TAG_TYPE：选择1 ，所有的ISO都可以发送应答（ISO西门子早期的以太网协议）
												RF_POWER：默认
												HW_CONNECT：
														两种连接方式
																TO_IDENT：创建Ident 工艺对象
																IID_HW_CONNECT：	
																		HW_ID：模块RF_120C的硬件标识符
																		LADDR：模块io地址						

						Read:读数据

								触发条件：

										EXECUTE：开关类型
										ADDR_TAG：默认
										LEN_DATA：是具体要读取的数据数组长度和写入长度相同
										HW_CONNECT：连接TO_IDENT工艺对象或者IID_HW_CONNECT
										IDENT_DATA：读取数组的db数据				

						Write:写数据

								触发条件：

										EXECUTE：开关类型
 										ADDR_TAG：默认
 										LEN_DATA：是具体要写入的数据数组长度和读取长度相同
 										HW_CONNECT：连接TO_IDENT工艺对象或者IID_HW_CONNECT
 										IDENT_DATA：写入数组的db数据					
		注意：
 		读写器一次一般只能执行112BYTE 根据芯片来决定
		

通过MODBUS TCP进行通信
		
		组态模块：
			
				通信-->其他-->Modbus Tcp
				
					使用MB_CLIENT的两个同名DB块（因为走一个协议所以应该是一个通道 用同一个db块）
						
						触发条件：
							写：
								REQ："AlwaysTRUE"或者做一个开关
								MB_MODE：1
								MB_DATA_ADDR：根据具体的读写器地址来决定，写和读，一致 例：40015
								CONNECT ：写和读使用同一个协议
								
							读：
								REQ：做一个开关
								MB_MODE：0
								MB_DATA_ADDR：根据具体的读写器地址来决定，写和读，一致 例：40015
								CONNECT ：写和读使用同一个协议
				
				
		报错：
		80A3:看读模式的块和写模式的块的名称是否不同，不同的db块会产生两个不同的通道，一个通讯协议不能在两个不同通道进行数据交换
		8383:看数据的长度和类型，国产的一般可以用INT进行通讯，可以将读取/写入的array数组改成INT数据类型，一般常见最长的长度是112个BYTE，也就是56个INT
		40011-40015 这四位是系统常数 总共是11位  前四位可以不读，所以可以写成40015 7位
```

**Modbus协议的数据模型和地址模型**

**数据模型**是对从站设备可访问的数据进行抽象，Modbus协议的数据模型定义了四种可访问的数据，为了简化数据模型与设备存储区的对应关系，又引入了**地址模型**的概念，通过编号的方式对不同类型数据进行区分，也就是通过特定的编号作为前缀加到所讨论的数据地址中。如表中所示，通过0,1,3,4分别表示线圈，离散量输入，输入寄存器，和保持寄存器。

| 地址前缀编号 | 编号范围(1~65536) | 编号范围(1~9999) | 数据区块                      | **数据**类型    | 访问类型 |
| ------------ | ----------------- | ---------------- | ----------------------------- | --------------- | -------- |
| **0**        | 000001~065536     | 00001~09999      | 线圈(Coils)                   | 布尔            | 读/写    |
| **1**        | 100001~165536     | 10001~19999      | 离散量输入(Discrete Input)    | 布尔            | 只读     |
| **3**        | 300001~365536     | 30001~39999      | 输入寄存器(Input registers)   | 无符号2字节整型 | 只读     |
| **4**        | 400001~465536     | 40001~49999      | 保持寄存器(Holding registers) | 无符号2字节整型 | 读/写    |

理论上，

线圈地址范围：000001~065536

离散量输入地址范围：100001~165536

输入寄存器地址范围：300001~365536

保持寄存器地址范围：400001~465536

由于65536是比较大的数值，实际应用一般不需要这么大的存储区，因此设备厂家普遍采用的是10000以内的地址范围，即：

线圈地址范围：00001~09999

离散量输入地址范围：10001~19999

输入寄存器地址范围：30001~39999

保持寄存器地址范围：40001~49999

有了该地址模型，我们就可以从Modbus寄存器的地址判断要访问的区块的类型。

### MODBUS (RTU)

```markdown
		组态硬件：

 				使用硬件CM1241进行组态以半双工RS485/232的方式进行通讯

 		组态模块：

 				通信-->通信处理器-->MODBUS(RTU)

 				Modbus_Comm_Load：组态Modbus 的端口

 						REQ："AlwaysTRUE"
 						BAUD：默认 ，数据传输速率
 						PARITY：默认，奇偶检验
 						FLOW_CTRL：默认，流控制
 						RTS_ON_DLY：50，接通延迟
 						RTS_OFF_DLY：50，关断延迟
 						RESP_TO：默认，响应超时时间
 						MB_DB：Modbus_Master.DB 对 Modbus_Master 或 Modbus_Slave 指令的背景数据块的引用	

 				Modbus_Master：作为主站通讯，写入通讯

 						触发条件：

 								REQ：常闭的写入DONE，写入BUSY，读取DONE，读取BUSY串联，并联常开的写入ERROR+5HZ时钟,并联常开的读取ERROR+5HZ时钟作为使能条件
 								MB_ADDR：一般为1，Modbus RTU 站地址 
 								MODE：1，读取
 								DATA_ADDR：从站中的起始地址，要根据实际设备的写入起始地址决定
 								DATA_LEN：要根据实际设备的写入地址长度决定
 								COM_RST：进行Modbus RTU 的重置
 								DATA_PTR：写入数据块，根据实际设备参数决定

 				Modbus_Master：作为主站通讯， 读取通讯

 						触发条件：

 								REQ：写入DONE作为使能条件，写入操作完成之后才能开始读取
 								MB_ADDR：一般为1，Modbus RTU 站地址 
 								MODE：0，读取
 								DATA_ADDR：从站中的起始地址，要根据实际设备的读取起始地址决定
 								DATA_LEN：要根据实际设备的读取地址长度决定
 								COM_RST：进行Modbus RTU 的重置
 								DATA_PTR：读取数据块，根据实际设备参数决定

 		案例：变位机伺服控制
```



### 工艺-轴控制

```markdown
		组态软件：轴工艺对象

 		组态模块：

 				MC_POWER :轴启动和停止

 						触发条件：

 								Axis：轴对象
 								Enable：常开使能开关
 								StartMode：1，轴位置控制
 								StopMode：0，停止模式

 				MC_RESET: 进行出错重置

 						触发条件：

 								Axis：轴对象
 								Execute：常开使能开关

 				MC_HOME: 回原点

 						触发条件：

 								Axis：轴对象
 								Execute：常开使能开关
 								Position：默认是0，回原点之后轴的相对位置
 								Mode：3,回原点的模式

 				MC_MoveAbsolute:绝对位移

 						触发条件：

 								Axis：轴对象
 								Execute：常开使能开关
 								Position：绝对目标位置，-1.0E12 ≤ Position ≤ 1.0E12
 								Velocity：轴的速度，启动/停止速度 ≤ Velocity ≤ 最大速度
 								Direction：默认是1，轴的运动方向，1是正方向，2是负方向，3是最短距离

 				MC_MoveRelative:相对位移

 						触发条件：
 								Axis：轴对象
 								Execute：常开使能开关
 								Distance：定位操作的移动距离
 								Velocity：轴的速度，启动/停止速度 ≤ Velocity ≤ 最大速度

 				MC_MoveJog:点动

 						触发条件：

 								Axis：轴对象
 								JogForward：常开使能开关，点动正向移动
 								JogBackward：常开使能开关，点动反向移动
 								Velocity：点动预设速度，启动/停止速度 ≤ 速度 ≤ 最大速度
 								PositionControlled：默认true

 				MC_ReadParam:读取轴对象参数比如：实时位置 			

 						触发条件：

 								Enable："AlwaysTRUE"
 								Parameter："轴_1".ActualPosition，获取轴的数据
 								Value：DB中定义的实际位置变量，指向写入所读取值的目标变量或目标地址的 VARIANT 指针

 		案例：旋转供料模块控制
```



### 硬件伺服控制

```markdown
		组态硬件：

 			IS620F-RT伺服

 				+驱动+111报文

 		组态模块：

 				SinaPos:报文111位置控制轴指令

 						触发条件：
 								ModePos：运动方式
 								EnableAxis：常开使能开关
 								CancelTraversing：默认，是否拒绝激活状态的运行作业
 								IntermediateStop：默认，激活状态的运行指令中断
 								Positive：默认，正方向
 								Negative：默认，正方向
 								Jog1：Jog 信号源1，正转
 								Jog2：Jog 信号源2，反转
 								FlyRef：默认，取消主动回原点参考
 								AckError：常开开关，故障应答/故障清除
 								ExecuteMode：常开开关，激活运行作业/接收设定值/激活回参考点功能
 								Position：具体模式执行的位置
 								Velocity：具体模式执行的速度
 								OverV：默认
 								OverAcc：默认
 								OverDec：默认
 								ConfigEPos：一般为16#07
 								HWIDSTW：伺服驱动对象报文
 								HWIDZSW：伺服驱动对象报文

 						响应重要参数：
 								AxisPosOk：使能是否成功状态
 								ActVelocity：当前速度
 								ActPosition：当前位置
 								ActMode：当前处于激活状态的运行模式
 								Error：是否存在故障
 								Status：故障错误码
```

### RS422

422全双工 读写可以同时进行
		全双工（Full Duplex）通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合。全双工指可以同时（瞬时）进行信号的双向传输（A→B且B→A）。指A→B的同时B→A，是瞬时同步的。

### RS485

通信模式

485半双工  只读或者只写，通信线路上的数据只能单向传输
半双工（Half Duplex）数据传输指数据可以在一个信号载体的两个方向上传输，但是不能同时传输。			RS485是串行数据传输的标准，主要用于多点通信，使用差分信号进行数据传输，也就是通过两根通信线之间的电压差表示传递的信号，一般采用主从的通讯模式，主站发送数据，从站接收数据，上传数据

电气特性

```markdown
逻辑电平：逻辑1表示电压在+2~+6v之间，逻辑0表示电压在-2~-6v之间
```

网络拓扑和节点数量

RS485总线，一条总线将各个节点串联起来，一般情况下可以接32个节点

### 不同的设备使用了不同的通讯协议，这两者怎么进行通讯？

1.使用网关或者协议转换器

 网口 **MODBUS TCP** 转  串口**MODBUS (RTU)**    使用 **串口服务器**

**Profinet**转**MODBUS (RTU)**  协议需要使用  **Profinet 转 MODBUS (RTU) 网关**

**MODBUS (RTU)** 转**EtherCAT** 需要使用**RS485转EtherCAT网关**

2.将有线的转为无线的网关

串口转Lora

串口转RF(无线射频)

串口转MQTT（MQTT可以连接到云平台，云平台可以连接不同类型的设备，方便远程监控和管理）

## 自定义程序块

### 西门子plc中input 和output还有inout有什么功能怎么使用？

**Input**：只读，PLC读取外部信号。

**Output**：只写，PLC向外部设备发送控制信号。

**InOut**：读写，既可以传入数据，也可以输出数据，适用于需要传递并修改数据的函数块或程序模块。

## 编程优化

```markdown
使用FB数据块的#I  
	优点
        程序清晰
        调用方便
	出现数据长度不一致，看代码中的#I 使用是否正确
使用流程步
    优点：
        验证效率高
        结构清晰

    缺点：
        测试程序复位比较麻烦
        流程步设置成0会影响其他流程
设置程序号
	通过程序号可以控制plc的程序分步执行
```

## 

## 参考文献

工业互联网：https://blog.csdn.net/weixin_45586124/article/details/136580828

[驽马同学](https://blog.csdn.net/qq_37424623)：https://blog.csdn.net/qq_37424623/article/details/116642032

B站匹尔西：https://space.bilibili.com/381962124