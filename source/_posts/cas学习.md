---
title: cas学习
typora-root-url: cas
abbrlink: 969d9481
date: 2022-11-26 17:01:46
keywords: 'cas'
tags: 
categories: 
photos:
description: cas学习
---

cas学习

<!--more-->

------



### cas

#### cas在Hotspot虚拟机中的实现

1.在Hotspot虚拟机中，cas (Compare And Swap) 操作是通过汇编指今实现的，底层涉及到CPU的原子操作

2.Hotspot使用了Unsafe类来提供cas操作的支持，Unsafe类是一个提供了一系列底层操作的工具类，它允许java程序直接访间底层内存和执行特定的操作，是Hotspot虚拟机的一部分，

3 **Unsafe**类中的compaeAndSwapInt、 compaeAndSwapIong、compaeAndSwapObject是cas操作的具体实现，这些法接收三个参教:内存地址、期望值和更新值，它们会很据底层平台的特性，使用汇编指令来进行原子比较和交换操作。

4.在X86架构下，Hotspot使用了lock cmpxchg指令来实现cas操作，该指令会比较内存中的值与期望值，如果相等，则用更新值替换内存中的值，并返回操作前的值，如果不相等，则不会进行替换操作，

5在执行cas操作时，Hotspot会使用内存屏障（memory barrier） 来保证可见性和有序性。

内存屏障有三种类型 LoadLoad屏障 、LoadStore屏障 、StoreStore屏障。

LoadLoad屏障保证在其前面的读操作完成后，后面的读操才可开始，StoreStore屏保证在其前面的写操完成后，后面的写操作才可开始，LoadStore屏保证在其前面的读操完成后，后面的写操作才可开始，

#### 乐观锁

乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。

乐观锁的实现方式有两种：cas机制和版本号机制

 

cas是乐观锁的一种实现，cas全称是比较和替换，cas的操作主要由以下几个步骤组成：

​        1.先查询原始值

2.操作时比较原始值是否修改

3.如果修改，则操作失败，禁止更新操作，如果没有发生修改，则更新为新值

上述三个步骤是一个原子性操作，不可以被拆分执行。

#### 乐观锁加锁吗？

（1）乐观锁本身是不加锁的，只是在更新数据的时候会判断一下数据是否被其他线程已经更新过了

（2）有时乐观锁可能与加锁操作两者同时使用

 

 假设有两个线程——线程1和线程2，两个线程按照顺序进行以下操作

 (1)线程1读取内存中数据为A；

 (2)线程2将该数据修改为B；

 (3)线程2将该数据修改为A；

 (4)线程1对数据进行cas操作

 

 在第(4)步中，由于内存中数据仍然为A，因此cas操作成功，但实际上该数据已经被线程2修改过了。这就是ABA问题。

 

 在AtomicInteger的例子中，ABA似乎没有什么危害。但是在某些场景下，ABA却会带来隐患，例如栈顶问题：**一个栈的栈顶经过两次(或多次)变化又恢复了原值，但是栈可能已发生了变化。**

 

 对于ABA问题，比较有效的方案是引入版本号，内存中的值每发生一次变化，版本号都+1；在进行cas操作时，不仅比较内存中的值，也会比较版本号，只有当二者都没有变化时，cas才能执行成功。

#### cas的优势

cas是一种无锁操作，不需要加锁，避免了线程切换的开销。

#### cas的问题

cas虽然在低并发量的情况下可以减少系统的开销，但是cas也有一些问题：

**CPU开销过大问题** ：使用cas时，如果并发量过大，我们的程序有可能会一直自旋，长时间占用CPU资源

**ABA问题** ：

假设有个共享变量J，原始值为1。

1.线程A读取变量J，值为1

2.线程B读取变量J，值为1

3.线程A变量J+1，cas成功从1修改为2

4.线程C读取变量J，值为2

5.线程C将变量J-1，cas成功从2修改为1

6.线程A通过cas比较和替换，依然可以改为自己想修改的值

上述过程，线程B和C已经将变量J的值已经改变了，但是线程A无法发现，依然可以修改共享变量，这就产生了ABA问题。

**只能针对一个共享变量** ：

cas操作单个共享变量的时候可以保证原子的操作，无法操作多个变量。但是在JDK5之后，AtomicReference可以用来保证对象之间的原子性，我们可以把多个对象放入cas中操作。

##### aba问题 常见的一些解决办法:

使用版本号(判断版本号一致值相同再经行设置新值操作)

使用定长数组，这样就可以提前分配好内存，就不涉及内存分配，避免aba出现。（这是一个非常巧妙的思路 很多项目都用到了这招）

##### 如何防止cas的aba

方案：加版本号（version）

至于版本号可以是自增的数字，也可以是时间戳。通过版本号我们可以精确的知道每次修改。

#### cas的一个基本操作流程

读取数据-->操作数据-->原数据是否修改

​						-->否-->更新数据

​						-->是-->读取数据(继续走一遍流程直到更新成功)

 

#### cas如何保证原子性

多核和多处理器 使用cpu指令lock cmpxchg 可以保证其原子性

单核可以不加lock ，即使增加也会被替换为nop

对共享内存，通过LOCK#信号在指令操作期间，锁住系统总线，来保证原子性。

对于已经被缓存的数据，通过Cache lock来保证原子性。Cache ock是通过缓存一致性协议，来保证修改的原子性，而不是通过总线锁，这样可以提高性能。

CPU 为了解决并发问题，提供了 cas 指令。作为一条 CPU 指令，cas 指令本身是能够保证原子性的。

 

汇编语言的程序中指令前面加上前缀“LOCK”,电位拉低,从而把总线锁住,保证了这条指令在多处理器环境中的原子性。



volatile底层实现主要是通过汇编lock前缀指令

volatile保证可见性与有序性，但是不保证原子性。

Volatile不能保证原子性的原因：

volatile读取写入都是原子的，但是本地计算不是

读取写入各4个步骤+计算，没有vo关键字，每一步都是会有并发问题，而加了vo以后就好很多了，但还是没全拦到

#### 常见指令的操作细节

| 操作类型      | 操作细节                                                     |
| ------------- | ------------------------------------------------------------ |
| lock(锁定)    | 作用于主内存的变量，把一个变量标记为一条线程独占状态         |
| unlock(解锁） | 作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定 |
| read(读取)    | 作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用 |
| load(载入)    | 作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中 |
| use(使用)     | 作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎 |
| assign(赋值)  | 作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量 |
| store(存储)   | 作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作 |
| write(写入)   | 作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变靠中 |

#### 共享变量的存取和使用

![图片](./20231101200722.png)

#### 版本号机制

版本号机制也可以用来实现乐观锁。版本号机制的主要思想是在数据中增加一个字段version，表示该数据的版本号，每当数据被修改时，同时读取版本号version的值，若刚才读取到的version值为当前数据库中的version值相等时才更新，则版本号加1；否则重试更新操作，直到更新成功。当某个线程查询数据时，将该数据的版本号一起查出来；当该线程更新数据时，判断当前版本号与之前读取的版本号是否一致，如果一致才进行操作。

#### cas在java中的哪些类用到?

cas 在 jdk 中主要应用在 J.U.C 相关包下的 Atomic 相关类中，主要有 AtomicInteger、AtomicLong、AtomicBoolean、AtomicDouble、AtomicReference、AtomicReferenceFieldUpdater 

例:AtomicInteger 类下的 getAndUpdate  

第一步：首先通过 get () 方法获取到当前对象的 value。

第二步：updateFunction 为函数引用，不过他的操作也是为了赋值，并返回预期结果。

第三步：进行 cas 操作，传入第一步 get () 获取到的值和目前对象中的值进行比较，如果一样就修改为 next, 不一样就继续循环，直到 cas 操作返回 true 为止。

第四步：返回当前获取到的值 prev。

 





### jvm

#### jvm常用参数

![图片](./c6cc405bb7caaf22ec.jpg)

### 参考文章：

[知乎君慕贤](https://www.zhihu.com/people/javajiao-fu-56):https://zhuanlan.zhihu.com/p/287855051