---
title: mysql
typora-root-url: mysql
date: 2022-11-26 16:14:49
tags:
permalink:
---

## mysql

阿里巴巴使用的数据库是myFox 基于mysql开发的数据库  

#### Mysql的执行顺序

客户端请求查询到我们的服务端获取链接先去查缓存缓存没有,解析sql(看sql语法正不正确)进行预处理(检查表明列名是否存在且正确,进行权限认证) 进行查询优化加入执行计划加入执行引擎通过api接口查询数据返回客户端页面

成本：硬件优化

> 系统配置优化
>
> 表结构优化
>
> SQL语句优化
>
> 索引优化。

效果：索引优化

> SQL语句优化
>
> 表结构优化
>
> 系统配置优化
>
> 硬件优化。

#### 什么情况下需要建立索引

 数据量大的，经常进行查询操作的表要建立索引。

 用于排序的字段可以添加索引，用于分组的字段应当视情况看是否需要添加索引。

 表与表连接用于多表联合查询的约束条件的字段应当建立索引。

#### 索引的优缺点

 优点：

​	建立索引可以有效缩短数据的检索时间

 	     建立索引可以加快表与表之间的连接

 缺点：

 	会降低表的增删改的效率，因为每次增删改索引需要进行动态维护，导致时间变长  

 	创建索引和维护索引需要时间成本，这个成本随着数据量的增加而加大  

索引分类:

#### 开启慢查询日志 记录执行慢的sql

\#查询数据状态

show variables like '%query%';

\#开启慢查询日志 ON  关闭 OFF

set global slow_query_log='ON';

set global slow_query_log='OFF';

\#设置输出格式

show variables like '%log_output%';

\#进入mysql容器

docker exec -it mysql57-3306 bash

\#进入mysql

mysql -uroot -p;

select sleep(11);

\#进行11秒的查询

select sleep(11);

select  from mysql.slow_log;

\#设置超过1秒的数据为满查询

set global long_query_time=1.0;

#### Mysql执行慢原因?

 索引失效

 数据量太多

#### 索引失效的情况?

\1. where语句中包含or时，可能会导致索引失效, 导致引擎放弃使用索引而进行全表扫描。sql查询速度慢(6-7秒),而改用union之后，性能就大大提高了(不到一秒)。这两个结果集合会以UNION-ALL的方式被合并， 然后在输出最终结果前进行排序。 如果用UNION ALL替代UNION， 这样排序就不是必要了，效率就会因此得到提高。

所以使用"union all"的性能比"union"更高一些。

or改成in?

有些说法认为in语句一样会导致全表扫描。in和not in的写法都是应该尽量避免的。

如果需要查询的特定值是连续的数值范围，如90--100，可以改用bwteen...and语句。

\2. where语句中索引列使用了负向查询，可能会导致索引失效

负向查询包括：NOT、!=、<>、!<、!>、NOT IN、NOT LIKE等。

其实负向查询并不绝对会索引失效，这要看MySQL优化器的判断，全表扫描或者走索引哪个成本低

\3. 索引字段为null，使用is null或is not null时，可能会导致索引失效

其实单个索引字段，使用is null或is not null时，是可以命中索引的，字段要设为not null并提供默认值，是有原因值得参考的。

null的列使索引/索引统计/值比较都更加复杂，对MySQL来说更难优化。

null这种类型MySQL内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条件下，表中有较多空字段的时候，数据库的处理性能会降低很多。

\4. 在索引列上使用内置函数，一定会导致索引失效

隐式字符编码转换导致的索引失效

当两个表之间做关联查询时，如果两个表中关联的字段字符编码不一致的话，MySQL可能会调用CONVERT函数，将不同的字符编码进行隐式转换从而达到统一。作用到关联的字段时，就会导致索引失效。

方案1: 将关联字段的字符编码统一。
 方案2: 实在无法统一字符编码时，手动将CONVERT函数作用到关联时=的右侧，起到字符编码统一的目的，这里是强制将utf8mb4转为utf8，当然从超集向子集转换是有数据截断风险的。

\5. 对索引列进行运算，一定会导致索引失效

优化的话，要把运算放在值上，或者在应用程序中直接算好

\6. like通配符可能会导致索引失效

like查询以%开头时，会导致索引失效

解决办法有两种：

将%移到后面

利用覆盖索引来命中索引

7.联合索引中，where中索引列违背最左匹配原则，一定会导致索引失效

##### 最左匹配原则

如果你的 SQL 语句中用到了联合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个联合索引去进行匹配。

最左匹配原则你可以定义一个联合索引，但是使得多数查询条件都可以用到该索引。

当遇到范围查询(>、<、between、like)就会停止匹配。

如果是建立(a,c,b)联合索引，则a,b,c都可以使用索引，因为优化器会自动改写为最优查询语句

，索引index1:(a,b,c)，只会走a、a,b、a,b,c 三种类型的查询，其实这里说的有一点问题，a,c也走，但是只走a字段索引，不会走c字段。

c无序后，所以c就没法走索引，数据库会觉得还不如全表扫描c字段来的快。

索引的底层是一颗 B+ 树，那么联合索引当然还是一颗 B+ 树，数据库依据联合索引最左的字段来构建 B+ 树。

######  什么时候不遵循最左前缀原则?

MySQL8.0版本开始增加了索引跳跃扫描的功能，当第一列索引的唯一值较少时，即使where条件没有第一列索引，查询的时候也可以用到联合索引。  

####  覆盖索引




 InnoDB聚集索引的叶子节点存储行记录，因此， InnoDB必须要有，且只有一个聚集索引：

 （1）如果表定义了主键，则PK就是聚集索引；
 （2）如果表没有定义主键，则第一个非空唯一索引（not NULL unique）列是聚集索引；
 （3）否则，InnoDB会创建一个隐藏的row-id作为聚集索引；




普通索引(单字段)和联合索引,以及唯一索引都能实现覆盖索引的作用。  

##### `如何实现索引覆盖？`

###### 1、常见的方法是：将被查询的字段，建立到联合索引里去。

 例子

```
create table user (
id int primary key,
name varchar(20),
sex varchar(5),
index(name)
)engine=innodb;
```

 第一个sql：

 select id,name from user where name='shenjian';

![img](lu285616d6d5_tmp_238d2bbcb87d603b.png) 

 能够命中name索引，索引叶子节点存储了主键id，通过name的索引树即可获取id和name，无需回表，符合索引覆盖，效率较高。

 Extra：Using index。

 第二个sql：

```
select id,name,sex from user where name='shenjian';
```

 


![img](lu285616d6d5_tmp_4d1d442d335ae188.png) 

 能够命中name索引，索引叶子节点存储了主键id，没有储存sex，sex字段必须回表查询才能获取到，不符合索引覆盖，需要再次通过id值扫描聚集索引获取sex字段，效率会降低。

 Extra：Using index condition。

 如果把(name)单列索引升级为联合索引(name, sex)就不同了。

```
create table user1 (
id int primary key,
name varchar(20),
sex varchar(5),
index(name, sex)
)engine=innodb;
```

 ![img](lu285616d6d5_tmp_e9ee48f83eea107a.png) 

 


 可以看到：

 select id,name ... where name='shenjian';
 select id,name,sex ... where name='shenjian';
 单列索升级为联合索引(name, sex)后，索引叶子节点存储了主键id，name，sex，都能够命中索引覆盖，无需回表。

 画外音，Extra：Using index。




####  什么是回表?

```
当我们使用 k 这个索引来查询 k = 2 的记录时就要用到回表。select  from xttblog where k = 2; 原因是通过 k 这个普通索引查询方式，则需要先搜索 k 索引树，然后得到主键 ID 的值为 1，再到 ID 索引树搜索一次。这个过程虽然用了索引，但实际上底层进行了两次索引查询，这个过程就称为回表。 

解决回表查询的方式就是使用覆盖索引
```

##### 为什么要使用联合索引  

- 减少开销
- 覆盖索引
- 效率高

##### 使用索引优化常见问题：  

 1、创建单列索引还是多列索引？如果查询语句中的where、order by、group 涉及多个字段，一般需要创建多列索引

2、多列索引的顺序如何选择？一般情况下，把选择性高的字段放在前面

3、避免使用范围查询 很多情况下，范围查询都可能导致无法使用索引。

4、尽量避免查询不需要的数据

5、查询的数据类型要正确

##### explain 执行计划怎么看（key   type ）

 type=const表示通过索引一次就找到了； 
 key=primary的话，表示使用了主键； 
 type=all,表示为全表扫描； 
 key=null表示没用到索引。

 type=ref，因为这时认为是多个匹配行，在联合查询中，一般为REF。

##### explain是什么呢？

 使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。

##### explain能做什么呢？

1.查看表的读取顺序

2.数据读取操作的操作类型

3.哪些索引可以使用

4.哪些索引被实际使用

5.表之间的引用

6.表中有多少行被优化器查询

##### Explain关键字解释

1、id：select查询的序列号,包含一组数字，表示查询中执行select子句或操作表的顺序，他分为三种情况：

id相同，执行顺序由上至下

id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行

id相同不同，同时存在

2、select_type：查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询，包括如下：

SIMPLE：简单的 select 查询,查询中不包含子查询或者UNION

PRIMARY：查询中若包含任何复杂的子部分，最外层查询则被标记

SUBQUERY：在SELECT或WHERE列表中包含了子查询

DERIVED：在FROM列表中包含的子查询被标记为DERIVED(衍生)MySQL会递归执行这些子查询, 把结果放在临时表里。

UNION：若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED

UNION RESULT：从UNION表获取结果的SELECT

3、table：显示这一行的数据是关于哪张表的

4 type：显示查询使用了何种类型，从最好到最差依次是：system>const>eq_ref>ref>range>index>ALL

### 分库分表

常用工具：

比较常见的包括：cobar、TDDL、atlas、sharding-jdbc、mycat
 Cobar:是阿里B2B开发和开源的，最近几年每更新，差不多算被抛弃的状态。
 TDDL：淘宝开发的，属于Client，不支持join、多表查询等语法，基本的增删改查还是好的，支持读写分离，用的也不多。
 Atlas:360开发的，有些公司还在用，基本没有公司用来。
 Sharding-jdbc:当当开源，之前用的比较多，支持分库分表，读写分离，id生成，还有一些在用，算当中活跃的。
 Mycat：基于codar改造的，属于proxy层方案，支持的功能非常完善，而且目前应该是非常火的而且不断流行的数据看看中间件，社区很活跃，也有一些公司开始在用了。但是的确相比于sharding jdbc来说，年轻一些，经理的锤炼少一些。  

分表：

 切分字段（垂直分表）  按

切分记录（水平分表） 按月分表

分库：

#### 按业务分库    库存，价格相关的接口 独立成不同的库

按表分库  订单数据特别多每次添加都需要50ms  这时候就要考虑通过表id分   1-10一个库  10-20一个库

#### 读写分离（不用mycat也可以实现，但是建议使用mycat），分库分表，分库工具mycat工具

 Mycat读写分离原理

Mycat读写分离是基于MySQL集群的主从复制实现的，而Mycat负责SQL分析，并将分析出的结果分发至与Mycat读写分离机制所绑定的MySQL主从复制数据库，从而实现读写分离。

主数据库 从数据库   主数据库负责写    从数据库负责读   大数据进来的时候  读多  用从库 写多  用主库

### 索引数据结构： b树 ，b+树， 为什么使用b+树,B树和B+树的总结

#### B树、B+树都是什么

原理:利用平衡树的优势加快查询的稳定性和速度；

B+树的数据都存储在叶子结点中，分支结点均为索引，查询时只需要扫描叶子节点，常用于数据库索引；

B树其分支结点和叶子节点都存储着数据，查询时需要进行一个遍历，常用于文件索引；

 B树和B+树区别

数据存储位置不同：B+树数据存储在叶子结点上；B树存储在每个结点上；

查询不同：B+树是从根节点到叶子节点的路径；B树是只需要找到数据就可以

非叶子节点存储信息不同：B+树存索引信息；B树存的是数据关键字

B树的特点:

节点排序,节点下存储的元素也经行排序,一个节点可以存多个元素

B+树的特点:

​	叶子节点之间有指针 , mysql的范围查找需要指针通过指针判断确定查询范围.  

树从叶节点开始生成然后数据量达到一定量, 向上新建一个索引, 然后继续在叶子节点存储数据,存储的元素都是有序的

在叶子节点的元素在在非页子节点都冗余了一份  非页子节点都是索引一级索引二级索引

​	一个节点下有多个元素

B\树： 在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；

详细说明

为什么使用B树？

B类树是平衡树(多路搜索树)，每个结点到叶子结点的高度都是相同，这也保证了每个查询是稳定的，查询的时间复杂度时 O（log2n）  ( 时间复杂度排序:  O（1）< O（log2n）< O（n）< O（n^2）)

其次是构造一个多阶B类树，然后在尽量多的在结点上存储相关的信息，保证层数尽量的少，以便后面我们可以更快的找到信息；

总结：利用平衡树的优势加快查询的稳定性和速度。

B树上大部分的操作所需要的磁盘存取次数和B树的高度是成正比的，在B树中可以检查多个子结点，由于在一棵树中检查任意一个结点都需要一次磁盘访问，所以B树避免了大量的磁盘访问。

B+树

 mysql为什么要使用B+树

1. B+树能显著减少IO次数，提高效率(原因: 	B+树的非叶子节点是主键，主键占用的空间越小，每个节点能放的主键就能更多，这就是为什么我们的主键一般不设置太大的原因。主键占用的空间小，能降低树高，减少IO次数。

)

2.B+树的查询效率更加稳定，因为数据放在叶子节点( 原因: 在B树的基础上每个节点存储的关键字数更多，树的层级更少所以查询数据更快，所有关键字指针都存在叶子节点，所以每次查找的次数都相同所以查询速度更稳定。)

3.B+树能提高范围查询的效率，因为叶子节点指向下一个叶子节点

 什么是聚簇索引什么是非聚簇索引

#### 什么是聚簇索引？

 很简单记住一句话：找到了索引就找到了需要的数据，那么这个索引就是聚簇索引，所以主键就是聚簇索引，修改聚簇索引其实就是修改主键。

#### 什么是非聚簇索引？

 索引的存储和数据的存储是分离的，也就是说找到了索引但没找到数据，需要根据索引上的值(主键)再次回表查询,非聚簇索引也叫做辅助索引。

### SQL优化的思路：

  1.优化更需要优化的sql；

  2.定位优化对象的性能瓶颈：优化前需了解查询的瓶颈是IO还是CPU，可通过PROFILING很容易定位查询的瓶颈。

  3.明确优化目标；

  4.从Explain入手；

#### 索引的好处：

（1）提高数据检索效率，降低数据库的IO成本。

（2）降低数据排序成本：要求排序字段和索引键字段一致。

（3）降低数据分组成本：因为分组之前会先排序，同意如果分组字段与索引字段一致，会降低分组消耗的成本。

#### 索引的弊端：

（1）.索引是独立于基础数据的数据库对象，因此它会占用存储空间。

（2）.数据新增、更新会导致索引的同步更新，所以会增加数据新增、更新所消耗的成本。

#### 判断是否需要创建索引：

（1）较为频繁的作为查询条件的字段需要创建索引；

（2）唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件；

（3）更新非常频繁的字段不适合创建索引；

（4）不会出现在where子句中的字段不要创建索引；

#### 索引语法：

1）.唯一索引

​     ALTER TABLE tableName ADD UNIQUE indexName (column);

​     CREATE UNIQUE INDEX indexName ON tableName (column);

2）.普通索引

​     ALTER TABLE tableName ADD INDEX indexName(column);

​     CREATE INDEX indexName ON tableName(column);

3）.主键索引

​     ALTER TABLE tableName ADD PRIMARY KEY (column);

4）.全文索引

​     ALTER TABLE tableName ADD FULLTEXT (column);

5）.组合索引

​     ALTER TABLE tableName ADD INDEX indexName(col1,col2,...);

很多查询优化工作实际上就是遵循一些原则，让MySQL的优化器能够按照预想的合理方式运行而已。

 ![img](lu152441l02jn_tmp_a4379d80c0a81f1a.jpg) 

### 事务

#### 什么是事务?

程序中一系列严密的逻辑操作，而且所有操作必须全部成功完成，否则在每个操作中所作的所有更改都会被撤消。(就像保密局特工要活一起活要死一起死)

事务能否生效数据库引擎是否支持事务是关键。比如常用的 MySQL 数据库默认使用支持事务的 innodb引擎。但是，如果把数据库引擎变为 myisam，那么程序也就不再支持事务了！  

#### 数据库事务的四大特性：CAID

1、原子性：事务包含的所有数据库操作要么全部成功，要不全部失败回滚

2、一致性：一个事务执行之前和执行之后都必须处于一致性状态。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。

3  隔离性：一个事务未提交的业务结果是否对于其它事务可见。级别一般有：read_uncommit，read_commit，read_repeatable，Serializable 串行化访问。

4、持久性：一个事务一旦被提交了，那么对数据库中数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

#### 数据库的隔离级别

事务并发造成的问题3种

1.脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据。比如：

事务B把用户的年龄更新成22岁，但是事务还未提交。此时事务A来读用户的年龄，读到了22岁，然后去做自己的处理。之后事务B把用户的年龄回滚到21岁。这个例子中事务A读到的22岁就是脏数据。http://www.chacha8.cn/detail/1132398235.html

2.不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。比如：

事务B先把用户的余额更新为100元，事务A来读的时候读到的是100元，然后事务B又把余额更新为90元，此时事务A来读的时候读到的就是90元，也就是事务A读到的数据前后不一致。

3.幻读：事务A对表中的数据进行了修改，涉及到表中的全部行。同时，事务B也修改这个表中的数据，向表中插入一行新数据。那么，事务A发现表中还有自己没有修改的行，就好象发生了幻觉一样。比如：

A先把所有人的余额清零，同时，B往表中插入了一条余额为100的数据。A提交以后，发现竟然还有100的。就好像发生了幻觉一样，这就叫幻读。

MySQL的事务隔离级别

MySQL的事务隔离级别有四种：

1.读未提交(read-uncommitted)：能读到未提交的数据。会出现脏读、不可重复读、幻读。

2.读已提交(read-committed)：读已提交的数据。会出现不可重复读和幻读。

3.可重复读(repeatable-read)：mysql默认的事务隔离级别，查询的都是事务开始时的数据。只会出现幻读。

4.串行读(serializable)：完全串行化读，每次都会锁表，读写互相阻塞。最高隔离级别，不会出现脏读，不可重复读，幻读。但会大大影响系统的性能，一般不用。

#### 事务控制的3种方式

- - 编程式事务：就是直接在代码里手动开启事务，手动提交，手动回滚。优点就是可以灵活控制，缺点就是太麻烦了，太多重复的代码了。
  - 声明式事务：就是使用SpringAop配置事务，这种方式大大的简化了编码。需要注意的是切入点表达式一定要写正确。
  - 注解事务：直接在Service层的方法上面加上@Transactional注解，个人比较喜欢用这种方式。

声明式事务和注解事务回滚的原理：当被切面切中或者是加了注解的方法中抛出了RuntimeException异常时，Spring会进行事务回滚。默认情况下是捕获到方法的RuntimeException异常，也就是说抛出只要属于运行时的异常（即RuntimeException及其子类）都能回滚；但当抛出一个不属于运行时异常时，事务是不会回滚的。  

3种事务不回滚的产生原因：

 （1）声明式事务配置切入点表达式写错了，没切中Service中的方法

 （2）Service方法中，把异常给try catch了，但catch里面只是打印了异常信息，没有手动抛出RuntimeException异常

 （3）Service方法中，抛出的异常不属于运行时异常（如IO异常），因为Spring默认情况下是捕获到运行时异常就回滚

 正常情况下，按照正确的编码是不会出现事务回滚失败的。保证事务能回滚的方法

 （1）如果采用声明式事务，一定要确保切入点表达式书写正确

 （2）如果Service层会抛出不属于运行时异常也要能回滚，那么可以将Spring默认的回滚时的异常修改为Exception，这样就可以保证碰到什么异常都可以回滚。

 （3）只有非只读事务才能回滚的，只读事务是不会回滚的

 （4）如果在Service层用了try catch，在catch里面再抛出一个 RuntimeException异常，这样出了异常才会回滚

 5还可以直接在catch后面写一句回滚代码（TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();）来实现回滚，这样的话，就可以在抛异常后也能return 返回值；  

### InnoDB   MyISAM的区别

一、InnoDB支持事务，MyISAM不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。

二、MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用

三、InnoDB支持外键，MyISAM不支持

四、MySQL 在 5.1 之前版本默认存储引擎是 MyISAM，5.1 之后版本默认存储引擎是 InnoDB

五、InnoDB不支持FULLTEXT类型的索引

六、InnoDB中不保存表的行数，如select count() from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时MyISAM也需要扫描整个表

七、对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引

八、清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表

九、InnoDB支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like '%lee%'

#### myisam和innodb存储数据位置

Innodb存储文件有frm、ibd，而Myisam是frm、MYD、MYI

​        Innodb：frm是表定义文件，ibd是数据文件

​        Myisam：frm是表定义文件，myd是数据文件，myi是索引文件

#### 如何选择：

​    \1. 是否要支持事务，如果要请选择innodb，如果不需要可以考虑MyISAM；

​    \2. 如果表中绝大多数都只是读查询，可以考虑MyISAM，如果既有读也有写，请使用InnoDB。

​    \3. 系统奔溃后，MyISAM恢复起来更困难，能否接受；

​    \4. MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的，如果你不知道用什么，那就用InnoDB，至少不会差。

InnoDB为什么推荐使用自增ID作为主键？

​    答：自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。

#### innodb引擎的4大特性

​       插入缓冲（insert buffer),二次写(double write),自适应哈希索引(ahi),预读(read ahead)

##### 1.插入缓冲（insert buffer)

插入缓冲（Insert Buffer/Change Buffer）：提升插入性能，change buffering是insert buffer的加强，insert buffer只针对insert有效，change buffering对insert、delete、update(delete+insert)、purge都有效

只对于非聚集索引（非唯一）的插入和更新有效，对于每一次的插入不是写到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，如果在则直接插入；若不在，则先放到Insert Buffer 中，再按照一定的频率进行合并操作，再写回disk。这样通常能将多个插入合并到一个操作中，目的还是为了减少随机IO带来性能损耗。

使用插入缓冲的条件：

\ 非聚集索引

\ 非唯一索引

##### 2.二次写(double write)

当操作系统或者数据库进程在数据页写磁盘的过程中崩溃，Innodb可以在doublewrite缓存中找到数据页的备份而用来执行crash恢复。数据页写入到doublewrite缓存的动作所需要的IO消耗要小于写入到数据文件的消耗，因为此写入操作会以一次大的连续块的方式写入

在应用（apply）重做日志前，用户需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做，这就是double write

##### 3.自适应哈希索引(ahi)

Adaptive Hash index属性使得InnoDB更像是内存数据库。该属性通过innodb_adapitve_hash_index开启，也可以通过—skip-innodb_adaptive_hash_index参数

关闭

注：可以关闭自适应hash

生成hash索引的条件比较苛刻

1.索引是否被访问了17次

2.索引中的某个页已经被访问了100次

3.访问模式必须是一样的。

例如对于（a,b）访问模式情况：

where a = xxx

where a = xxx and b = xxx

Innodb存储引擎会监控对表上二级索引的查找，如果发现某二级索引被频繁访问，二级索引成为热数据，建立哈希索引可以带来速度的提升

经常访问的二级索引数据会自动被生成到hash索引里面去(最近连续被访问三次的数据)，自适应哈希索引通过缓冲池的B+树构造而来，因此建立的速度很快。

哈希（hash）是一种非常快的等值查找方法，在一般情况下这种查找的时间复杂度为O(1),  

innodb会监控对表上个索引页的查询。如果观察到建立哈希索引可以带来速度提升，则自动建立哈希索引，称之为自适应哈希索引（Adaptive Hash Index，AHI）。

特点

　　1、无序，没有树高

　　2、降低对二级索引树的频繁访问资源，索引树高<=4，访问索引：访问树、根节点、叶子节点

3、自适应  

3、缺陷

　　1、hash自适应索引会占用innodb buffer pool；

　　2、自适应hash索引只适合搜索等值的查询，如select  from table where index_col='xxx'，而对于其他查找类型，如范围查找，是不能使用的；

　　3、极端情况下，自适应hash索引才有比较大的意义，可以降低逻辑读。

##### 4.预读(read ahead)

InnoDB使用两种预读算法来提高I/O性能：线性预读（linear read-ahead）和随机预读（randomread-ahead）

为了区分这两种预读的方式，我们可以把线性预读放到以extent为单位，而随机预读放到以extent中的page为单位。线性预读着眼于将下一个extent提前读取到buffer pool中，而随机预读着眼于将当前extent中的剩余的page提前读取到buffer pool中。

### mysql的高并发问题

 1.sql执行慢  

 我们会先分析数据库是达到了io瓶颈和cpu瓶颈 io瓶颈我们就使用 根据业务需求分库和垂直分表 cpu瓶颈就采用水平分表（使用取模算法） 或者sql优化

 分库分表之后id使用雪花算法生成  

 2

 请求量过大导致数据库崩溃

 mysql集群还有读写分离解决高并发问题  

 没有解决高可用问题

 单点问题：1. mysql代理服务单点故障

 解决方案 把tomcat服务和mysql的服务搭载一台服务器上

 2.mysql主机单点故障

 给mysql做负载均衡 使用mysql的代理服务,将mysql的注册节点注册到代理服务器上通过代理服务实现负载均衡  

 3.削峰

### tomcat连接mysql集群方式：

 tomcat--->连接mysql代理服务--{这个过程实现了 1.对备机数据的读 对主机的写 实现读写分离 2.将请求转发到主机 }->连接多台mysql服务器

 mysql数据同步方式

 主机写入数据后 数据同时写到log日志里然后同步到两台备机中

### Char和varchar的区别

\1. char类型的长度是固定的，varchar的长度是可变的。

这就表示，存储字符串'abc'，使用char(10)，表示存储的字符将占10个字节（包括7个空字符）

使用varchar2(10),，则表示只占3个字节，10是最大值，当存储的字符小于10时，按照实际的长度存储。

2.char类型的效率比varchar的效率稍高

3.varchar 与 varchar2的区别

varchar2是oracle开发的一个数据类型。

工业标准的varchar可以存储空字符串，oracle的varchar2还可以存储NULL值，如果想要有向后兼容的能力建议使用varchar2

4.varchar2比char节省空间，但是在效率上比char稍差些。既要获得效率即必须牺牲一点空间，这就是设计上的"以空间换时间"

varchar2虽然比char节省空间，但是一个varchar2列经常被修改，而且每次修改的数据长度不同，这会引起“行迁移的现象”,而这造成的多余的I/O，是数据库设计中尽量避免的，在这种情况下使用char代替varchar2会更好些。

总结：1.如果一个字段经常被修改，而且每次修改的数据长度不同，为了效率应当考虑用char定长代替varchar2变长。（列如一个用户的名字经常被修改）

\2. 设计的时候尽量考虑  用空间换时间。

### Mysql 的提交一般想进行修改后再提交怎么做?

通过mybatis或mybatisplus设置sql拦截拦截到后进行修改再提交  

## 数据库锁

#### 锁的粒度分数据库锁有哪些？

行级锁：MySQL中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁和排他锁。

特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

表级锁：MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MyISAM与InnoDB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。

特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。

页级锁：是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。

### 三范式:

1.原子性：强调的是列的原子性，即数据库中每一列的字段都是单一属性，不可再分的。

2.一张表必须有一个主键；非主键类必须完全依赖于主键，而不能只依赖主键的一部分。

3.非主键列必须直接依赖于主键，不能存在传递依赖。

### Mysql存儲過程:

MySQL 存储过程是一些 SQL 语句的集合，比如有时候我们可能需要一大串的 SQL 语句，或者说在编写 SQL 语句的过程中需要设置一些变量的值，这个时候我们就完全有必要编写一个存储过程。

 如何使用存储过程？

使用存储过程需要：1）先定义存储过程 2）使用已经定义好的存储过程。

![img](lu152441l02jn_tmp_50e103a18fc602c6.png)   

 业务比较复杂、重复性工作比较多，存储过程会比较实用。

#### 优点:  

Sql过程化

界面与逻辑分离

性能好

#### 缺点:

移植性差

调试困难

体系封闭

耦合性高

管理困难

安全性差

### 外键的优缺点

优势：  

  设置外键可以保证数据的完整性与关联性，杜绝数据冗余

  级联操作方便，比如涉及一个离职用户的所有相关信息，可以直接删除这个用户就能做到所有信息一起删除的操作

缺点：

  主表进行修改或变更，会波及一大片从表，顿时会使公司部分业务处于不可用的状态，不利中小公司的设计，一般中小型公司都没有dba，开发人员对数据库了解的不够深，容易误操作，所以建议不用使用过多的外键来操作相关业务表

  而且对于insert,   update,   delete等操作时都会先检查外键的约束条件再操作，性能有所下降

## sql锁  

#### 表锁

 当索引失效的时候，行锁会升级成表锁，索引失效的其中一个方法是对索引自动 or 手动的换型。a 字段本身是 integer，我们加上引号，就变成了 String，这个时候索引就会失效了。

 表锁的优势：开销小；加锁快；无死锁
 表锁的劣势：锁粒度大，发生锁冲突的概率高，并发处理能力低
 加锁的方式：自动加锁。查询操作（SELECT），会自动给涉及的所有表加读锁，更新操作（UPDATE、DELETE、INSERT），会自动给涉及的表加写锁。也可以显示加锁：  

#### 行锁

 加锁的方式：自动加锁。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁；对于普通SELECT语句，InnoDB不会加任何锁；当然我们也可以显示的加锁：  

 行锁的劣势：开销大；加锁慢；会出现死锁
 行锁的优势：锁的粒度小，发生锁冲突的概率低；处理并发的能力强  

#### 行锁优化

 1 尽可能让所有数据检索都通过索引来完成，避免无索引行或索引失效导致行锁升级为表锁。
 2 尽可能避免间隙锁带来的性能下降，减少或使用合理的检索范围。
 3 尽可能减少事务的粒度，比如控制事务大小，而从减少锁定资源量和时间长度，从而减少锁的竞争等，提供性能。
 4 尽可能低级别事务隔离，隔离级别越高，并发的处理能力越低。

#### 共享锁

 共享锁，也称读锁，多用于判断数据是否存在，多个读操作可以同时进行而不会互相影响。当如果事务对读锁进行修改操作，很可能会造成死锁。

#### 排他锁

 排他锁，也称写锁，独占锁，当前写操作没有完成前，它会阻断其他写锁和读锁。

#### 间隙锁

 当我们用范围条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做`"``间隙``(GAP)"`。InnoDB也会对这个"间隙"加锁，这种锁机制就是所谓的间隙锁(Next-Key锁)。

 作用：

 `只有``RR``隔离级别才存在间隙锁。`

 间隙锁在一定程度上可以解决幻读的问题，但是间隙锁的引入,更多是为了处理binlog的statement模式的bug。

 Bug:

 master库有这么两个事务：

1、事务a先delete id<6，然后在commit前；
 2、事务b直接insert id=3，并且完成commit；
 3、事务a进行commit；
 此时binlog记录的日志是：事务b先执行，事务a在执行（binlog记录的是commit顺序）

那么主库此时表里面有id=3的记录，但是从库是先插入再删除，从库里面是没有记录的。

这就导致了主从数据不一致。

#### 数据库sql语句  数据库表直接加锁

 FOR UPDATE

 SELECT  FROM child WHERE id > 100 FOR UPDATE;  

### 外键的优缺点

 优势：  

   设置外键可以保证数据的完整性与关联性，杜绝数据冗余

   级联操作方便，比如涉及一个离职用户的所有相关信息，可以直接删除这个用户就能做到所有信息一起删除的操作

 缺点：

   主表进行修改或变更，会波及一大片从表，顿时会使公司部分业务处于不可用的状态，不利中小公司的设计，一般中小型公司都没有dba，开发人员对数据库了解的不够深，容易误操作，所以建议不用使用过多的外键来操作相关业务表

   而且对于insert,   update,   delete等操作时都会先检查外键的约束条件再操作，性能有所下降

## mysql日志

### 重做日志（redo log）

 作用：

 　　确保事务的持久性。redo日志记录事务执行后的状态，用来恢复未写入data file的已成功事务更新的数据。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启[mysql](https://www.2cto.com/database/MySQL/)服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。

### 回滚日志（undo log）

 作用：

 　　保证数据的原子性，保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也叫非锁定读

### 二进制日志（binlog）：

 作用：

 　　用于复制，在主从复制中，从库 利用 主库上的binlog进行重播，实现主从同步。

 　　用于数据库的基于时间点的还原。

### 普通查询日志 general query log

 　　记录了服务器接收到的每一个查询或是命令，无论这些查询或是命令是否正确甚至是否包含语法错误，general log 都会将其记录下来 ，记录的格式为 {Time ，Id ，Command，Argument }。也正因为mysql服务器需要不断地记录日志，开启General log会产生不小的系统开销。 因此，Mysql默认是把General log关闭的。

### 慢查询日志

 慢日志记录执行时间过长和没有使用索引的查询语句，报错select、update、delete以及insert语句，慢日志只会记录执行成功的语句。

\#查询数据状态

show variables like '%query%';

\#开启慢查询日志 ON  关闭 OFF

set global slow_query_log='ON';

\#进入mysql

mysql -uroot -p;

\#进行11秒的查询

select sleep(11);

MySQL与Oracle区别:
 1.对事务的提交:MySQL默认是自动提交，而Oracle默认不自动提交，需要用户手动提交，需要在写commit;指令或者点击commit按钮
 2.对事务的支持:MySQL在innodb存储引擎的行级锁的情况下才可支持事务，而Oracle则完全支持事务
 3.分页查询:MySQL是直接在SQL语句中写"select...from...where...limitx,y",有limit就可以实现分页;而Oracle则是需要用到伪列ROWNUM和嵌套查询  

## mysql oracle 分页有什么区别？

Mysql使用limit分页

​	第一个参数值m表示起始行，第二个参数表示取多少行（页面大小）

Oracle使用rownum分页

 	rownum只能比较小于，不能比较大于，因为rownum是先查询后排序的