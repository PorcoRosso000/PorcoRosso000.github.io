---
title: 关于锁的了解
typora-root-url: 关于锁的了解
abbrlink: '19169963'
date: 2022-11-26 13:16:17
tags:
permalink:
---



## 锁的特性

阻塞锁，可重入锁 ，读写锁 ，互斥锁 ，悲观锁 ，乐观锁 ，公平锁 ，偏向锁， 对象锁，[线程锁](https://so.csdn.net/so/search?q=线程锁&spm=1001.2101.3001.7020)，锁粗化， 锁消除，轻量级锁，重量级锁， [信号量](https://so.csdn.net/so/search?q=信号量&spm=1001.2101.3001.7020)，独享锁，共享锁，分段锁 

## 数据库锁

#### 锁的粒度分数据库锁有哪些？

行级锁：MySQL中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁和排他锁。

特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

表级锁：MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MyISAM与InnoDB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。

特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。

页级锁：是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。

## sql锁  

#### 表锁

 当索引失效的时候，行锁会升级成表锁，索引失效的其中一个方法是对索引自动 or 手动的换型。a 字段本身是 integer，我们加上引号，就变成了 String，这个时候索引就会失效了。

 表锁的优势：开销小；加锁快；无死锁
 表锁的劣势：锁粒度大，发生锁冲突的概率高，并发处理能力低
 加锁的方式：自动加锁。查询操作（SELECT），会自动给涉及的所有表加读锁，更新操作（UPDATE、DELETE、INSERT），会自动给涉及的表加写锁。也可以显示加锁：  

#### 行锁

 加锁的方式：自动加锁。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁；对于普通SELECT语句，InnoDB不会加任何锁；当然我们也可以显示的加锁：  

 行锁的劣势：开销大；加锁慢；会出现死锁
 行锁的优势：锁的粒度小，发生锁冲突的概率低；处理并发的能力强  

#### 行锁优化

 1 尽可能让所有数据检索都通过索引来完成，避免无索引行或索引失效导致行锁升级为表锁。
 2 尽可能避免间隙锁带来的性能下降，减少或使用合理的检索范围。
 3 尽可能减少事务的粒度，比如控制事务大小，而从减少锁定资源量和时间长度，从而减少锁的竞争等，提供性能。
 4 尽可能低级别事务隔离，隔离级别越高，并发的处理能力越低。

#### 共享锁

 共享锁，也称读锁，多用于判断数据是否存在，多个读操作可以同时进行而不会互相影响。当如果事务对读锁进行修改操作，很可能会造成死锁。

#### 排他锁

 排他锁，也称写锁，独占锁，当前写操作没有完成前，它会阻断其他写锁和读锁。

#### 间隙锁

 当我们用范围条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做`"``间隙``(GAP)"`。InnoDB也会对这个"间隙"加锁，这种锁机制就是所谓的间隙锁(Next-Key锁)。

 作用：

 `只有``RR``隔离级别才存在间隙锁。`

 间隙锁在一定程度上可以解决幻读的问题，但是间隙锁的引入,更多是为了处理binlog的statement模式的bug。

 Bug:

 master库有这么两个事务：

1、事务a先delete id<6，然后在commit前；
 2、事务b直接insert id=3，并且完成commit；
 3、事务a进行commit；
 此时binlog记录的日志是：事务b先执行，事务a在执行（binlog记录的是commit顺序）

那么主库此时表里面有id=3的记录，但是从库是先插入再删除，从库里面是没有记录的。

这就导致了主从数据不一致。

#### 数据库sql语句  数据库表直接加锁

 FOR UPDATE

 SELECT  FROM child WHERE id > 100 FOR UPDATE;  

### 可重入锁

也叫 做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受 影响  

 实现原理

通过为每个锁关联一个请求计数器和一个占有它的线程。当计数为0时，认为锁是未被占有的；线程请求一个未被占有的锁时，JVM将记录锁的占有者，并且将请求计数器置为1 。  

### 公平锁（Fair）

加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得  

### 非公平锁（Nonfair）

 加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待  

\1. 非公平锁性能比公平锁高 5~10 倍，因为公平锁需要在多核的情况下维护一个队列

\2. Java 中的 synchronized 是非公平锁，ReentrantLock 默认的 lock()方法采用的是非公平锁  

为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如 果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写 锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。  

### [乐观锁](https://so.csdn.net/so/search?q=乐观锁&spm=1001.2101.3001.7020)/悲观锁

乐观锁与[悲观锁](https://so.csdn.net/so/search?q=悲观锁&spm=1001.2101.3001.7020)不是指具体的什么类型的锁，而是指看待并发同步的角度。悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。悲观锁在Java中的使用，就是利用各种锁。乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。

### 读锁

 如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁  

### 写锁

 如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上 读锁，写的时候上写锁！ Java 中读写锁有个接口 java.util.concurrent.locks.ReadWriteLock ，也有具体的实现 ReentrantReadWriteLock  

java 并发包提供的加锁模式分为独占锁和共享锁。

### 独占锁  

独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。 独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线 程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。  

### 共享锁  

共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。共享锁则是一种 乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。  

\1. AQS 的内部类 Node 定义了两个常量 SHARED 和 EXCLUSIVE，他们分别标识 AQS 队列中等 待线程的锁获取模式。

\2. java 的并发包中提供了 ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问， 或者被一个 写操作访问，但两者不能同时进行

### 重量级锁（Mutex Lock）  

Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又 是依赖于底层的操作系统的 Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用 户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么 Synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为 “重量级锁”。JDK 中对 Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。 JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和 “偏向锁”。

### 轻量级锁  

锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。  

### 偏向锁  

Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线 程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所 以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进 一步提高性能。  

### 锁升级的过程

锁 还有锁升级过程  轻量级锁自旋十次会变成重量级锁

 1.一开始，没有任何线程访问同步块，此时同步块处于无锁状态。
 2.然后，线程1首先访问同步块，它以CAS的方式修改MarkWord，尝试加偏向锁。由于此时没有竞争，所以偏向锁加锁成功，此时MarkWord里存储的是线程1的ID。
 3.然后，线程2开始访问同步块，它以CAS的方式修改MarkWord，尝试加偏向锁。由于此时存在竞争，所以偏向锁加锁失败，于是线程2会发起撤销偏向锁的流程（清空线程1的ID），于是同步块从偏向线程1的状态恢复到了可以公平竞争的状态。
 4.然后，线程1和线程2共同竞争，它们同时以CAS方式修改MarkWord，尝试加轻量级锁。由于存在竞争，只有一个线程会成功，假设线程1成功了。但线程2不会轻易放弃，它认为线程1很快就能执行完毕，执行权很快会落到自己头上，于是线程2继续自旋加锁。
 5.最后，如果线程1很快执行完，则线程2就会加轻量级锁成功，锁不会晋升到重量级状态。也可能是线程1执行时间较长，那么线程2自旋一定次数后就放弃自旋，并发起锁膨胀的流程。届时，锁被线程2修改为重量级锁，之后线程2进入阻塞状态。而线程1重复加锁或者解锁时，CAS操作都失败，此时它就会释放锁并唤醒等待的线程。
 总之，在锁升级的机制下，锁不会一步到位变为重量级锁，而是根据竞争的情况逐步升级的。当竞争小的时候，只需以较小的代价加锁，直到竞争加剧，才使用重量级锁，从而减小了加锁带来的开销。  

​      

 ![lu152441l02jn_tmp_c9b183e3ea279b7a](lu152441l02jn_tmp_c9b183e3ea279b7a.png)

##### 锁升级:

![img](lu152441l02jn_tmp_56b6da453920189d.png) 

在jdk1.6之后，对synchronized进行了优化，对于一个锁对象有如下6种状态：

非锁不可偏向状态、非锁可偏向状态、偏向锁状态、轻量级锁状态、重量级锁状态和GC状态

非锁不可偏向状态与非锁可偏向状态的区别

首先是非锁，说明这两种状态下，当前对象还不是一个锁，仅仅是一个普通的对象而已。

不同点就在于一个是不可偏向状态，另一个是可偏向状态。

可偏向状态很好理解，就是当这个对象作为一个锁，被一个线程所持有的时候，这个对象会变成一个偏向锁的状态。

那么为什么会有一个不可偏向状态呢？

因为运行java程序启动虚拟机的时候，JVM内部的代码也有很多地方用到了synchronized，如果还需要从偏向状态再逐步的升级，那么是没有必要的。所以JVM设置了一个偏向锁的启动延迟，相关的JVM参数是-XX:BiasedLockingStartupDelay=4000，可以设置成0，表示取消启动延迟。

启动延迟表示在这个时间还没到的时候，所创建出来的对象，就不让他有机会从偏向锁的状态开始升级，而是直接从轻量级锁的状态开始。

MarkWord中所记录的信息包含了锁对象的6种状态

一个对象在java堆当中由3部分组成：对象头，对象属性，对齐填充。其中对齐填充不是必须有的，是为了保证整个对象的大小是8字节的倍数。

对象头又是由两部分组成的，一部分是MarkWord，另一部分是一个指针指向方法区（元空间）中的类元信息，也就是表明这个对象属于哪个类



### 锁优化  

减少锁持有时间  

只用在有线程安全要求的程序上加锁  

减小锁粒度  

将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。 降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是 ConcurrentHashMap。  

锁分离  

最常见的锁分离就是读写锁 ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互 斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能，具体也请查看[高并发 Java 五] JDK 并发包 1。读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比如 LinkedBlockingQueue 从头部取出，从尾部放数据  

锁粗化  

通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完 公共资源后，应该立即释放锁。但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步 和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。  

锁消除  

锁消除是在编译器级别的事情。在即时编译器时，如果发现不可能被共享的对象，则可以消除这 些对象的锁操作，多数是因为程序员编码不规范引起  



### 乐观锁加锁吗？

（1）乐观锁本身是不加锁的，只是在更新数据的时候会判断一下数据是否被其他线程已经更新过了

（2）有时乐观锁可能与加锁操作两者同时使用

 假设有两个线程——线程1和线程2，两个线程按照顺序进行以下操作

 (1)线程1读取内存中数据为A；

 (2)线程2将该数据修改为B；

 (3)线程2将该数据修改为A；

 (4)线程1对数据进行CAS操作

 在第(4)步中，由于内存中数据仍然为A，因此CAS操作成功，但实际上该数据已经被线程2修改过了。这就是ABA问题。

 在AtomicInteger的例子中，ABA似乎没有什么危害。但是在某些场景下，ABA却会带来隐患，例如栈顶问题：一个栈的栈顶经过两次(或多次)变化又恢复了原值，但是栈可能已发生了变化。

 对于ABA问题，比较有效的方案是引入版本号，内存中的值每发生一次变化，版本号都+1；在进行CAS操作时，不仅比较内存中的值，也会比较版本号，只有当二者都没有变化时，CAS才能执行成功。

   CAS
 什么是CAS？CAS的本质是把compare-and-swap封装为一个原子操作。

 是一条CPU并发原语，用于判断内存中某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。

### ReentrantLock和 Lock的关系

ReentrantLock位于java.util.concurrent（J.U.C）包下，是Lock接口的实现类。基本用法与synchronized相似，都具备可重入互斥的特性，但拥有扩展的功能。

### Synchronized锁和lock锁的区别?



#### 两种锁的底层实现

 Synchronized：底层使用指令码方式来控制锁的，映射成字节码指令就是增加来两个指令：monitorenter和monitorexit。当线程执行遇到monitorenter指令时会尝试获取内置锁，如果获取锁则锁计数器+1，如果没有获取锁则阻塞；当遇到monitorexit指令时锁计数器-1，如果计数器为0则释放锁。

 Lock：Lock 底层是通过 AQS + CAS 机制来实现的。 ，依赖AbstractQueuedSynchronizer类，把所有的请求线程构成一个CLH(同步队列)。而对该队列的操作均通过Lock-Free（CAS）操作。

   lock-free的概念
 什么是lock-free，简单的说就是不直接使用锁，减少锁在系统中占用的开销。相比于基于锁的算法而言，Lock-free 算法具有明显的特征：某个线程在执行数据访问时挂起不会阻碍其他的线程继续执行（某个线程持有锁之后挂起，导致其他的线程没有办法申请锁）。这意味着在任意时刻，多个 lock-free 线程可以同时访问同一数据而不产生数据竞争。

 上面的定义保证了 lock-free 程序中的一组线程中至少有一个可以顺利的执行而不产生阻塞，从而确保整个程序的顺利执行。lock-free中常见的就是使用cas来代替加锁。



#### 应用场景

在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态；

### Synchronized，lock锁区别， 底层，锁升级

区别:

 1.Synchronized是关键字，内置语言实现，Lock是接口。

 2.Synchronized在线程发生异常时会自动释放锁，因此不会发生异常死锁。Lock异常时不会自动释放锁，所以需要在finally中实现释放锁。

 3.Lock是可以中断锁，Synchronized是非中断锁，必须等待线程执行完成释放锁。

 4.Lock可以使用读锁提高多线程读效率。

 5.synchronized是java底层支持的，而concurrent包则是jdk实现。

 底层:

 Synchronized：底层使用指令码方式来控制锁的，映射成字节码指令就是增加来两个指令：monitorenter和monitorexit。当线程执行遇到monitorenter指令时会尝试获取内置锁，如果获取锁则锁计数器+1，如果没有获取锁则阻塞；当遇到monitorexit指令时锁计数器-1，如果计数器为0则释放锁。

 Lock：Lock底层实现基于AQS实现，采用线程独占的方式，在硬件层面依赖特殊的CPU指令（CAS）。

 简单来说，ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。

### 什么是死锁? 如何解决

死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。

#### 常见的解决死锁的方法

活锁:

两个线程互相让资源出来,最后两个线程都没法使用资源

饿死:

类似于非公平锁机制,多个线程在等待资源,有一个早就在等待的线程一直获取不到锁,反而是后面的线程获取了锁

死锁:

死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。

#### 产生死锁的四个必要条件(四个条件同时满足产生死锁)

　　　1.互斥性：线程对资源的占有是排他性的，一个资源只能被一个线程占有，直到释放。

　　　2.请求和保持条件：一个线程对请求被占有资源发生阻塞时，对已经获得的资源不释放。(持有一个资源不释放,又在等待另一个资源)

　　　3.不剥夺：一个线程在释放资源之前，其他的线程无法剥夺占用。

　　　4.循环等待：发生死锁时，线程进入死循环，永久阻塞。(循环等待)

#### 产生死锁的原因

##### 1.竞争不可抢占性资源

p1已经打开F1，想去打开F2，p2已经打开F2，想去打开F1，但是F1和F2都是不可抢占的，这是发生死锁。

##### 2.竞争可消耗资源引起死锁

进程间通信，如果顺序不当，会产生死锁，比如p1发消息m1给p2，p1接收p3的消息m3，p2接收p1的m1，发m2给p3，p3，以此类推，如果进程之间是先发信息的那么可以完成通信，但是如果是先接收信息就会产生死锁。

##### 3.进程推进顺序不当

进程在运行过程中，请求和释放资源的顺序不当，也同样会导致产生进程死锁。

### 死锁解决方案分析:

破坏其中一个必要条件

1.远行前申请到所有的资源,缺点线程并发率降低,资源利用率降低

2.允许线程强行从占有者哪里争夺某些资源

3.避免出现申请环路,对资源事先进行编号,按号分配,这种方式可以有效提高资源利用率和系统吞吐量,但是增加系统开销,增大线程对资源的占用时间.

### 死锁的解决方案:

1.通过协议预防或者避免死锁,确保系统不会进入死锁状态

2.可以允许系统进入死锁状态,然后检测它,并加以恢复

### 死锁的检测和恢复:

1.重启,代价大(之前线程的工作白做)

2.撤销线程,剥夺资源.终止参与死锁的线程,收回占有的资源,从而解决死锁

​	1.一次性撤销参与死锁的全部线程,剥夺全部资源

​	2.逐步撤销参与死锁的线程,逐步收回线程占有的资源

3.线程回退策略(实现难度高)

4.如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。

5.在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率。

6.业务上使用分布式锁和乐观锁。

### 分布式锁产生死锁怎么解决?

使用看门狗机制,然后给锁续期,设置一个超时时间超过这个时间就给锁释放掉

