---
title: 计算机底层原理
typora-root-url: 计算机底层原理
tags: 计算机底层原理
categories: 计算机底层原理
abbrlink: 3bdc281c
date: 2024-01-12 14:18:46
permalink:
---



## 计算机底层原理

### cpu是如何制作的？

一堆沙子 +一堆铜 + 一堆胶水 + 特定金属添加+ 特殊工艺

沙子脱氧 -> 石英 ->二氧化硅-> 提纯 -> 硅-> 切割 -> 晶圆-> 涂抹光刻胶 -> 光刻 -> 蚀刻 > 清除光刻胶 -> 电镀 -> 抛光 -> 铜层 -> 测试 -> 切片 ->封装

**cpu的核心是晶体管**

计算机的核心是找到一种方式可以代表数字，有进行运算的方式

发展史： 机械摇把式计算机 -> 真空管计算机（不稳定，笨重） -> 晶体管计算机

晶体管通一次电可以进行一次单次的计算

硅-> 加入特殊元素-> P半导体 N半导体 -> PN结 -> 二极管 -> 场效应晶体管 -> 逻辑开关

与门 或门 非门 或非门 已非门 异或非门 -> 基础逻辑电路加法器 累加器 锁存器
实现手动计算(通电一次，运行一次位运算)
加入内存 实现自动运算 (每次读取内存指令（高电低电）)

### 计算机的组成：

![img](./计算机组成图.png)

cpu 内部组成：

cpu通过总线读取内存中的数据

内存中存取的一条一条的指令

**程序计数器（指令计数器pc）**：用于存放指令的地址，指向当前需要取出的指令，当CPU从内存中取出一个指令以后，EIP/IP就自动增加，指向下一个指令的地址。这样看来上下文切换实际就是寄存器的切换。

cpu要做计算的时候，通过pc中指令的地址从内存中拿到对应的数据，读到**寄存器(Registers)**中，然后通过cpu的**运算单元（ALU）**运算，之后再写到内存中去

### 存储的层次结构

![img](./存储的层此结构.png)



主存的中取数据的速度大概是寄存器的100分之一

![img](./速度对比.png)

多级缓存的结构

![img](./多级缓存结构.png)

为了取数据更快，内存会将数据存储在L3,L2,L1中，然后cpu去取数据的时候，先从L1中查找数据,找不到数据的情况下，会从L2,L3中依次查找数据，最后再在内存中去查找数据

每个核中有L1,L2 ,多个核共享三级缓存L3，多块cpu共享内存

#### 线程:

线程中的指令放程序计数器中,线程中的数据放到寄存器中

线程的切换: 多线程执行的时候,要将线程的数据存到内存中,线程执行一半中止了,其它线程执行完之后,要从内存中拿到之前线程执行的数据恢复到程序计数器和寄存器中继续执行线程

#### 超线程:

一个ALU对应多个PC/寄存器

四核八线程就是  四个ALU(计算单元)对应两组寄存器和PC

#### cpu读取数据

cpu读取数据的时候是很多个数据一起读取的,数据是0还是1其实就是线有没有通电,总线是很多根线

找数据是从L1->L2->L3->内存 

cpu从内存中读取数据的时候是一块一块的读取的(假如只需要数据a,它会读取含a的一块数据,不是只读取a),一块数据叫一个缓存行(cache line,64个字节),读取到数据之后缓存到L3->L2->L1下次需要数据直接从L1中取数据

**为什么只读取64字节数据?**

缓存行缓存行越大，局部性空间效率越高，但读取时间慢缓存行越小，局部性空间效率越低，但读取时间快取一个折中值，目前多用:64字节

为了避免相邻的数据在不同cpu中反复修改,可以让这俩数据不在同一个缓存行,比如数据设置成long类型,前面或者后面加七个long 类型数据,一个long类型是8字节



**缓存一致性协议:** 

MESI Cache 一致性协议 四种状态

Modified 被修改

Exclusive 独享

Shared 分享

Lnvalid 失效



使用缓存一致性协议保证cpu中的数据一致

在一个核中缓存行修改了,修改完的数据会强制写道内存中,相同的缓存行在另一个核中就会失效(使用缓存锁实现),必须从内存中去读取最新的

缓存一致性协议是**缓存锁**实现之一有些无法被缓存的数据或者跨越多个缓存行的数据依然必须使用**总线锁**

### bug的由来

原始的纸带算计需要给纸带上打眼进行计算，小飞虫把眼堵住了，然后程序一直有问题，英语的小飞虫叫bug

0101010 太繁琐，之后就出现 助记符 （起别名）

给0101010起一个别名，这种语言叫做**汇编语言**（就是机器语言）

高级语言 -> 编译器（将高级语言翻译成计算机可以识别的语言） -> 机器语言

