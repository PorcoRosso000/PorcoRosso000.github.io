---
title: 高并发
typora-root-url: 高并发
abbrlink: ace12490
date: 2022-11-26 17:06:32
tags:
permalink:
---



## 并发量

//---------------------------------------------

Tomcat 并发量：500qps  

Mysql：3000qps  

Redis：5万-8万

Nginx：5万-10万

 网站并发量：3000,5000,8000, 在线用户，电商x50 ，其它互联网项目x80 ， 注册用户，在在线用户的基础上x50.(3000的并发:服务器一台tomcat支持500 所以要六台以上可以加两台 说8台)

 Tomcat (web应用服务器)

 nginx /apache(web服务),为文件服务器nginx性能是tomcat的10倍以上

内存标记 :消耗tomcat内存 可以支持的并发量也比较低   所以使用redis redis存储数据存储在本地  并且redis的并发量会高很多

电商项目开发时间:一年以上开发  迭代一直在持续

7个人开发    

几千的并发  并发 乘以50 就是在线人数  再乘以50  就是总注册人数

3000的并发服务器设置的刀片机（或者我们搭建的集群服务）是8台服务器左右抢购微服务

在添加订单之前通过redis集群方式加mq进行

## 高内聚，低耦合

 内聚就是指程序内的各个模块之间关系的紧密程度,



 耦合是指各个外部程序(子程序)之间关系的紧密程度.



 为什么要高内聚? 模块之间的关系越紧密,出错就越少!



 低耦合? 子程序间的关系越复杂,就会产生更多的意想不到的错误!会给以后的维护工作带来很多麻烦



 // 注释：“内紧而外松”

 内紧：程序内的模块之间要紧密相关，形成一个高效的功能单元；（旨在—创建高效的代码）

 外松：程序之间呢，要尽可能的不关联，各自实现各自的功能。（旨在—实现分工）



 秒杀订单多少   

 每天多少订单30000 3000并发量   



 秒杀订单的服务有几台   

 每天部署的有多少机器 平时秒杀并发量500-600  六台



 redis的锁过期时间  500ms  过期时间  看门狗锁过期续命原理  

 

## 限流

 

### Sentinel

Sentinel是阿里巴巴开发的一个流量控制、熔断和流量管理框架，它可以帮助我们在微服务架构中实现服务调用的容错、限流和流控。Sentinel的核心功能包括：

- 流控：限制请求数量，防止服务被过多的请求所击败。
- 熔断：当服务调用出现故障时，自动切换到备用方法，防止故障传播。
- 降级：在服务调用出现故障时，自动切换到备用方法，防止用户请求受影响。
- 系统负载保护：监控系统负载，当负载超过阈值时，自动进行流控或熔断。

Sentinel的核心思想是“限流”和“流控”，即在服务调用出现故障时，限制请求数量，防止服务被过多的请求所击败。同时，Sentinel还提供了一些规则配置，如流控规则、熔断规则等，可以根据具体情况进行调整。 

#### 实现原理:

**原理**是在访问web应用时，在web引用内部会有一个拦截器，这个拦截器会对请求的url进行拦截，并将拦截到的请求读取到sentinel控制台，从而对web应用设置相应的流控规则和需要的流控效果，之后基于这个流控规则和流控效果对流量进行限流操作。

 

Sentinel的**核心算法原理**是基于“限流”和“流控”的。当服务调用出现故障时，Sentinel会限制请求数量，防止服务被过多的请求所击败。同时，Sentinel还提供了一些规则配置，如流控规则、熔断规则等，可以根据具体情况进行调整。

 

**具体操作步骤如下：**

1.创建一个Sentinel流控规则，指定资源名称、流控条件、流控策略等。

2.在调用服务时，使用Sentinel流控规则进行控制。

3.当服务调用出现故障时，Sentinel会触发熔断器，切换到备用方法。

4.可以通过SentinelDashboard监控Sentinel流控规则的状态和统计信息。

#### 四种限流算法:

**对应三种流控效果:**

   **滑动窗口算法(默认):对应快速失败**

   **漏桶算法: 对应排队等待**

   **令牌桶算法: 对应预热** 

##### 固定窗口算法:

**固定窗口计数器算法**是限流算法中最简单也最容易实现的算法。它使用计数器在周期内累加访问次数，当达到设定的限流值时，触发限流策略。下一周期开始，清零重新计数。

举个例子，一个接口在1s内的负载限值为100，开始时设定一个计数器count=0，来一个请求count+1，1min内count<=100就能正常访问，count>100的请求就会被拒绝。

计数器算法的弊端在于只有最开始的100个请求能被访问，其余在限制时间内都不能访问。也就是突刺现象。这时就可以用滑动窗口算法解决这个问题。

突刺现象是指在一定时间内的一小段时间内就用完了所有资源，后大部分时间中无资源可用。

**优点**：分布式中实现难度低

**缺点：**不能平滑限流，存在临界问题，前一个周期的最后几秒和下一个周期的开始几秒时间段内访问量很大但没超过周期量计数量时，但短时间请求量依旧很高。

![img](1.jpg)


##### 滑动窗口算法(默认): 

**滑动窗口计数器算法**也是Sentinel的默认算法。滑动窗口算法是**将时间周期分为n个小周期，分别记录每个小周期内的访问次数 ，并且根据时间滑动删除过期的小周期**。

假设时间周期为1min，将1min再分割成2个小周期，统计每个小周期的访问数量，则可以看到，第一个时间周期内访问数量为75，第二个时间周期内访问数量为100，超过100的数量被限流掉了。

当滑动窗口格子划分得越多，那么滑动窗口的滚动就越平滑，限流的统计就越精确。可以很好的解决固定窗口的流动问题。

![img](2.jpg)

##### 漏桶算法: 

**漏桶算法是将访问请求放入漏桶中，当请求达到限流值，则进行丢弃（触发限流策略）**。无论有多少请求，请求的速率有多大，都按照固定的速率流出，对应到系统中就是按照固定的速率处理请求。超过漏桶容量的直接抛弃。

![img](3.jpg)

##### 令牌桶算法: 

令牌桶其实和漏桶的原理类似，令牌桶按固定的速率往桶里放入令牌，并且只要能从桶里取出令牌就能通过，令牌桶支持突发流量的快速处理。

![img](4.jpg)

###### 令牌桶和漏桶区别：

主要区别在于**“漏桶算法”能够强行限制数据的传输速率**，而**“令牌桶算法”在能够限制数据的平均传输速率外，还允许某种程度的突发传输**。在“令牌桶算法”中，只要令牌桶中存在令牌，那么就允许突发地传输数据直到达到用户配置的门限，因此它适合于具有突发特性的流量。

### 基于Redis的分布式令牌桶实现

Redis中有incr命令实现原子自增、如果每个调用appKey请求一次，我们对其自增1，如果一秒内超过500，就拒绝当前请求能够实现我们的需求。如何统计1秒内呢，我们可以利用过期机制，设定当前请求计数的key过期时间为1s，但是incr没有提供原子操作的incr过期时间，该如何实现呢？

``` java
local key =KEYS[1]

local expire_time =ARGV[1]

local count =redis.call("INCR", key, 1)

if count == 1 then

    redis.call("EXPIRE", key, expire_time)

end

return count
```

其中KEYS[1]为计数的appKey、ARGV[1]为一个计时时间间隔，单位为s。 最后利用redis的eval命令执行lua脚本，实现incr与expire的原子操作：

``` java
Long current = (Long) jedis.eval(INCR_LUA_SCRIPT, Arrays.asList(key)), Arrays.asList( “1”));

if (current > 500) return false;

return true
```



## 参考文献：

作者：garychenqin 

链接：https://www.jianshu.com/p/08aa952e8bc2



