---
title: redis
typora-root-url: redis
abbrlink: 7b25d017
date: 2022-11-26 16:34:04
tags:
permalink:
---



## Redis

![img](lu152441l02jn_tmp_110d4c2beb54bd82.png) 过期策略
 Reids分布式锁，及应用场景，reidsson。
 redisson信号量项目中的应用，有什么优势
 redisssonReadLock

### Redis的使用场景:

单点登录，订单，库存，地址隐藏，接口防刷，对象缓存化（商品对象）,分布式锁

### Redis的插件

redis desktop manager

medis

### 5种数据类型，及应用

string  list  hash   set  zset

String :

​	应用场景:

​		缓存结构体信息

计数功能

List:

应用场景:

​		list列表结构常用来做异步队列使用

​	 	list可用于秒杀抢购场景

Hash:

​	应用场景:

​		保存结构体信息

Set:

​	应用场景:

​		用在一些去重的场景里(每个用户只能参与一次活动、一个用户只能中奖一次)

Zset:

​	应用场景:

​		各类热门排序场景(歌单排序,微博列表,评论列表,点赞数)

### redis的持久化机制

 为什么要持久化

Redis是内存数据库，宕机后数据会消失，Redis重启后快速恢复数据，要提供持久化机制。

Redis的两种持久化方式：RDB和AOF

Redis持久化不保证数据的完整性，有可能会丢数据。当Redis用作DB时，DB数据要完整，所以一定要有一个完整的数据源（文件、mysql），在系统启动时，从这个完整的数据源中将数据load到Redis中。

RDB方式

RDB（Redis DataBase），是redis默认的存储方式，RDB方式是通过快照（ snapshotting ）完成的。它保存的是某一时刻的数据并不关注过程。RDB保存redis某一时刻的数据的快照

RDB的优缺点

优点

1.RDB是二进制压缩文件，占用空间小，便于传输（传给slaver）；

2.主进程fork子进程，可以最大化Redis性能；

3.使用RDB文件来恢复数据较快。

缺点

1、不保证数据完整性，会丢失最后一次快照以后更改的所有数据；

2、父进程在fork子进程的时候如果主进程比较大会阻塞；

AOF方式

AOF（append only file）是Redis的另一种持久化方式。Redis默认情况下是不开启的。开启AOF持久化后Redis 将所有对数据库进行过写入的命令（及其参数）（RESP）记录到 AOF 文件， 以此达到记录数据库状态的目的，这样当Redis重启后只要按顺序回放这些命令就会恢复到原始状态了。AOF会记录过程，RDB只管结果

RDB与AOF对比

1、RDB存某个时刻的数据快照，采用二进制压缩存储，AOF存操作命令，采用文本存储(混合);

2、RDB性能高、AOF性能较低;

3、RDB在配置触发状态会丢失最后一次快照以后更改的所有数据，AOF设置为每秒保存一次，则最多丢2秒的数据;

4、Redis以主服务器模式运行，RDB不会保存过期键值对数据，Redis以从服务器模式运行，RDB会保存过期键值对，当主服务器向从服务器同步时，再清空过期键值对;

5、AOF写入文件时，对过期的key会追加一条del命令，当执行AOF重写时，会忽略过期key和del命令。

6.AOF保存的数据更全更安全

实现混合持久化原理:

混合持久化并不是一种全新的持久化方式，而是对已有方式的优化。混合持久化只发生于 AOF 重写过程。使用了混合持久化，重写后的新 AOF 文件前半段是 RDB 格式的全量数据，后半段是 AOF 格式的增量数据。  

本质是通过 AOF 后台重写（bgrewriteaof 命令）完成的，不同的是当开启混合持久化时，fork 出的子进程先将当前全量数据以 RDB 方式写入新的 AOF 文件，然后再将 AOF 重写缓冲区（aof_rewrite_buf_blocks）的增量命令以 AOF 方式写入到文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的的 AOF 文件。

优点：结合 RDB 和 AOF 的优点, 更快的重写和恢复。
 缺点：AOF 文件里面的 RDB 部分不再是 AOF 格式，可读性差。  

### 穿透，雪崩，击穿

缓存雪崩:

缓存机器意外发生了全盘宕机。缓存挂了，此时大量请求全部落在数据库，数据库必然扛不住，它会报一下警，然后就挂了。此时，如果没有采用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了。

这就是缓存雪崩。

解决方案:

 事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。 - 事中：本地 ehcache 缓存 + hystrix 限流&降级，避免 MySQL 被打死。 - 事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。

缓存穿透

　　对于系统A，假设一秒 5000 个请求，结果其中 4000 个请求是黑客发出的恶意攻击。

黑客发出的那 4000 个攻击，缓存中查不到，每次你去数据库里查，也查不到。

举个栗子。数据库 id 是从 1 开始的，结果黑客发过来的请求 id 全部都是负数。这样的话，缓存中没有，请求每次都不经过缓存，直接查询数据库。这种恶意攻击场景的缓存穿透就会直接把数据库给打死。

解决方式很简单，每次系统 A 从数据库中只要没查到，就写一个空值到缓存里去，比如 set -999 UNKNOWN。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。

缓存击穿

　　缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。

　　解决方式也很简单，可以将热点数据设置为永远不过期；或者基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据。

### Redis 	key过期的方式有三种：

 定时删除

 1含义：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除

 优点：保证内存被尽快释放

 缺点：

 1.若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key

 2.定时器的创建耗时，若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重

 3.没人用

 惰性删除

 1.含义：key过期的时候不删除，每次从数据库获取key的时候去检查是否过期，若过期，则删除，返回null。

 2.优点：删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）

 3.缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）

 定期删除

 含义：每隔一段时间执行一次删除(在redis.conf配置文件设置hz，1s刷新的频率)过期key操作

 优点：

 1.通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用--处理"定时删除"的缺点4

 2.定期删除过期key--处理"惰性删除"的缺点

 缺点

 3.在内存友好方面，不如"定时删除"

 4.在CPU时间友好方面，不如"惰性删除"

 难点

 5.合理设置删除操作的执行时长（每次删除执行多长时间）和执行频率（每隔多长时间做一次删除）（这个要根据服务器运行情况来定了）

 看完上面三种策略后可以得出以下结论： 
 定时删除和定期删除为主动删除：Redis会定期主动淘汰一批已过去的key

 惰性删除为被动删除：用到的时候才会去检验key是不是已过期，过期就删除

 惰性删除为redis服务器内置策略

### key删除方式

被动删除：当读/写一个已经过期的key时，会触发惰性删除策略，直接删除掉这个过期key

主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以Redis会定期主动淘汰一批已过期的key

当前已用内存超过maxmemory限定时，触发主动清理策略

### 淘汰策略

当Redis实例的内存超过设置的maxmemory时，会根据配置的策略maxmemory-policy来对key进行淘汰，可选的淘汰策略有如下几种：

volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。

volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。

volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。

volatile-lfu：从已设置过期时间的数据集挑选使用频率最低的数据淘汰。

allkeys-lru：从数据集中挑选最近最少使用的数据淘汰

allkeys-lfu：从数据集中挑选使用频率最低的数据淘汰。

allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰

no-enviction（驱逐）：禁止驱逐数据，这也是默认策略。意思是当内存不足以容纳新入数据时，新写入操作就会报错，请求可以继续进行，线上任务也不能持续进行，采用no-enviction策略可以保证数据不被丢失。

这八种大体上可以分为4种，lru、lfu、random、ttl。

### redis删除过期数据的执行原理：

删除失效主键（消极、积极、主动）

淘汰数据的量（为了避免频繁的触发淘汰策略，每次会淘汰掉一批数据，淘汰的数据的大小其实是和置换的大小来确定的，如果置换的数据量大，淘汰的肯定也多。）

置换策略（在执行增加数据时，Redis会检查内存使用，如果内存使用超过maxmemory，就会按照置换策略删除一些key）

### redis序列化方式有哪几种

 jdk序列化方式（默认的）JdkSerializationRedisSerializer 使用这个序列化的bean必须实现Serializable接口 不方便人工排查 redis可视化中是二进制的

 JSON序列化方式GenericJackson2JsonRedisSerializer 使用这个redis会获取数据失败 原因是LocalDate这是java8新增的类，GenericJackson2JsonRedisSerializer序列化方式无法识别 多一个@class属性，添加这个属性解决了反序列化，但是json字符串占用变大。

 String序列化方式StringRedisSerializer 不能序列化Bean，只能序列化字符串类型的数据，如果key、value都是字符串类型，可以用该方式序列化

 xml序列化方式  

### redis事务

 redis事务提供一种机制： 将命令存入队列中，一次性执行，并且在事务执行的过程中，客户端发送来的命令也不会将事务中断  

 redis执行的时候包括三个阶段 开始事务 命令入队 执行事务

 开始事务：multi命令的执行就是表示事务的开始，开始事务要将客户端的redis_multi开启，就代表事务开始了

 命令入队：客户端发送的命令，会存入队列中，等到执行EXEC命令，开始执行事务，因为是放入队列中所以是先进去的先执行，后进去的后执行，多得到的结果也是一样的

执行事务：并不是说所有的事务都会去执行，如果执行的事务包括whatch、exec、discard、multi，会像客户端发送请求到服务器一样，直接被服务器执行

 执行事务的流程：如果客户端处于一个事务状态，那么当EXEC命令执行时候，服务器会根据保存的队列执行（先进先出），执行命令所得的结果也是FIFO的顺序，保存到一个回复列表中，当事务执行完毕之后，EXEC命令会最为回复列表返回给客户，将客户端的事务状态改为非事务状态，事务就结束了

### Redis的线程模型:

redis 内部使用文件事件处理器 file event handler，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。
 它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。

### io多路复用

单线程或单进程同时监测若干个文件描述符是否可以执行IO操作的能力。( 单进程/线程下同时关注多个文件描述符动态，哪个可用处理哪个 )

解决什么问题:   IO多路复用解决的本质问题是在用更少的资源完成更多的事。  比如 电脑，需要同时处理键盘鼠标的输入、中断信号等等事件  nginx 同一时间需要处理多个客户端的事件

![img](lu152441l02jn_tmp_58c32f6a88ef00db.gif) 

解决方案

Linux: select、poll、epoll  

io多路复用执行流程

 操作系统能在同一个进程/线程中同时监听多个fd上的可读可写状态。

 每 accept 一个客户端连接后，将这个[文件描述符](https://so.csdn.net/so/search?q=文件描述符&spm=1001.2101.3001.7020)（connfd）放到一个数组里。
 将这一批文件描述符通过一次系统调用传给内核，由内核层去遍历，才能真正解决这个问题。

 `多路`指多个文件描述符（fd），`复用`指复用同一个进程/线程

- `多路复用`` 	`就是一个线程处理多个[socket](https://so.csdn.net/so/search?q=socket&spm=1001.2101.3001.7020)
  在网络服务中，IO多路复用起的作用是`「一次性把多个连接的事件通知业务代码处理」`。

### IO多路复用的内核（一个线程监视多个socket的原理）

- 客户端socket服务端时会产生三种`文件描述符``(fd)`：writefds(写)、readfds(读)、和exceptfds(异常)。

 通过一种机制(select、poll、[epoll](https://so.csdn.net/so/search?q=epoll&spm=1001.2101.3001.7020))一个线程可以监视多个描述符，一旦某个描述符就绪，能够通知程序进行相应的操作。

 inux内核提供了select,poll,和epoll这3种I/O多路复用方案

- 整个处理过程只在select、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是`事件驱动`，所谓的`reactor``模式`。

### 为什么 redis 效率这么高？

 \1. 纯内存操作

 \2. 核心是基于非阻塞的 IO 多路复用机制

 \3. 单线程反而避免了多线程的频繁上下文切换问题

### 三级缓存

 一级缓存就是     储存最终的完整bean的容器

 二级缓存是        储存实例化但未初始化的半成品bean

 三级缓存是         为了加工二级缓存中的bean，加工成一个代理类bean

循环依赖问题的解决:

 使用二级缓存(半成品池)解决循环依赖  

 spring已经帮我们解决了非构造器的循环依赖问题，使用的就是内置的三级缓存

 如果是构造方法造成的循环依赖问题，那么可以使用@Lazy注解，来解决此问题

 但是二级缓存不能解决AOP代理的问题，属性A是半成品，不是A的代理类

 因为通过AOP的加工，所有bean都会加工成对应的代理类bean

三级缓存解决了循环依赖问题+bean不是AOP代理类的bean的问题  

 三级缓存是为了解决循环依赖存在的

为了解决半成品bean不是代理类bean的问题，三级缓存出现了，也称为工厂池  

三级缓存放lambda表达式，来完成代理对象的覆盖过程  

 使用三级缓存的本质为了解决AOP的代理问题

#### 三级缓存解决循环依赖问题的关键是什么？为什么通过提前暴露对象能解决？

 实例化和初始化分开操作，在中间过程中给其他对象赋值的时候，并不是一个完整对象，而是把半成品对象赋值给了其他对象。

#### 如果只使用一级缓存能不能解决问题？

 不能。在整个处理过程中，缓存中放的是半成品和成品对象，如果只有一级对象，那么成品和半成品都会放到一级缓存中，有可能在获取过程中获取到半成品对象，此时半成品对象是无法使用的，不能直接进行相关的处理，因此要把半成品和成品的存放空间分割开来。

#### 只使用二级缓存行不行？为什么需要三级缓存？

#### 三级和二级比，到底多了什么？

 三级比二级多了getEarlyBeanReference(beanName, mbd, bean)方法

#### 如果能保证所有的对象都不去调用getEarlyBeanReference方法，使用二级缓存可以嘛？

 可以

 为什么要加三级缓存，使用三级缓存的本质为了解决AOP的代理问题，就是说如果没有进行AOP的话，就能用二级缓存解决循环依赖的问题

#### 为什么使用三级缓存就能解决代理问题

 当一个对象需要被代理的时候，在整个创建过程中是包含两个对象的。一个是普通对象，一个是代理生成的对象，bean默认都是单例的，那么在整个生命周期的处理环节中，一个beanName不能对应两个对象，然后通过一个匿名内部类的方式，在使用的时候直接对普通对象进行覆盖操作，保证全局唯一对象！

#### 为什么三级缓存要有lambda表达式

 因为要给B对象的a属性赋值，但当时A只是完成了实例化还没有完成初始化操作，给传的是a.getEarlyBeanReference，就会判断对象是否需要生成对应的代理。调用此方法才会生成对应的代理

#### 为什么需要三级缓存？

 三级缓存的value类型是一个ObjectFactory，是一个函数式接口，存在的意义是保证在整个容器的运行过程中同名的bean对象只能有一个

 如果一个对象需要被代理，或者说需要生成代理对象，那个需要优先生成一个普通对象，用代理对象覆盖掉之前的普通对象。在实际的调用过程中，没有办法确定什么时候对象被使用，所以要求当某个对象被调用的时候，优先判断此对象是否需要被代理，类似于一种回调机制的实现，因此传入lambda表达式的时候，可以通过lambda表达式来执行对象的覆盖过程

 因此，所有的bean对象在创建的时候都要优先放入三级缓存中，在后续的使用过程中，如果需要被代理则返回代理对象，不需要则直接返回普通对象

#### mybatis默认开启一级缓存

### redis和mongodb有什么区别?

1.内存管理

Redis 数据全部存在内存，定期写入磁盘，当内存不够时，可以选择指定的 LRU 算法删除数据。

MongoDB 数据会优先存于内存，当内存不够时，只将热点数据放入内存，其他数据存在磁盘。

需要注意的是Redis 和mongoDB特别消耗内存，一般不建议将它们和别的服务部署在同一台服务器上。

2.数据结构

Redis 支持的数据结构丰富，包括hash、set、list等。

MongoDB 数据结构比较单一，但是支持丰富的数据表达，索引，最类似关系型数据库，支持的查询语言非常丰富。

3.数据量和性能

当物理内存够用的时候，性能，redis>mongodb>mysql

数据量，mysql>mongodb>redis

注意mongodb可以存储文件，适合存放大量的小文件，内置了GirdFS 的分布式文件系统。

4.可靠性

mongodb从1.8版本后，采用binlog方式（MySQL同样采用该方式）支持持久化，增加可靠性；

Redis依赖快照进行持久化；AOF增强可靠性；增强可靠性的同时，影响访问性能。

可靠性上MongoDB优于Redis。

5.事务支持情况

 Redis 事务支持比较弱，只能保证事务中的每个操作连续执行

 mongodb不支持事务

 6.TPS

总体来讲，TPS方面redis要大于mongodb  

7.应用场景

 redis：数据量较小的高性能的操作和运算上

 MongoDB: 主要解决海量数据的访问效率问题

redis除了缓存还能做什么   分布式锁   简易版本的消息队列  防重提交

### 只用redis不限流,如何解决百万并发量

集群，